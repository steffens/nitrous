{"version":3,"sources":["constraint-solver/datatypes.js","constraint-solver/catalog-cache.js","constraint-solver/catalog-loader.js","constraint-solver/constraint-solver-input.js","constraint-solver/version-pricer.js","constraint-solver/solver.js","constraint-solver/constraint-solver.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,sB;;AAEA,wB;AACA,0B;;AAEA,4B;;AAEA,yC;AACA,oD;AACA,yB;AACA,yB;;AAEA,yB;AACA,yB;AACA,E;;AAEA,+D;AACA,8D;AACA,mD;AACA,uD;AACA,2C;AACA,E;;AAEA,kD;AACA,6B;AACA,mD;AACA,wD;AACA,U;AACA,2D;AACA,G;AACA,E;;AAEA,qB;;AAEA,mE;AACA,4B;;AAEA,qD;AACA,8C;AACA,4E;AACA,wE;AACA,G;AACA,8C;AACA,qE;AACA,G;AACA,c;AACA,yB;AACA,G;;AAEA,6C;AACA,sB;;AAEA,c;AACA,uB;AACA,yB;AACA,K;AACA,G;AACA,E;;AAEA,6D;AACA,6D;AACA,gD;AACA,8C;AACA,oB;AACA,oB;AACA,G;AACA,a;AACA,E;;AAEA,2C;AACA,qB;;AAEA,8B;AACA,kB;AACA,uB;AACA,G;;AAEA,+C;;AAEA,uC;AACA,E;;;;;;;;;;;;;;;;;;;AChFA,0B;AACA,wB;;AAEA,yC;AACA,iC;AACA,E;;AAEA,4D;AACA,+B;AACA,uD;AACA,8E;AACA,0B;AACA,yE;AACA,4B;AACA,0E;AACA,6D;AACA,sB;AACA,E;;AAEA,2E;AACA,4D;AACA,E;;AAEA,qE;AACA,mB;AACA,mB;AACA,8E;AACA,+B;;AAEA,wB;AACA,uC;AACA,wD;AACA,G;;AAEA,mC;AACA,2B;AACA,G;AACA,4B;AACA,mC;;AAEA,yB;AACA,0C;AACA,6B;AACA,yC;AACA,mC;AACA,8D;AACA,oC;AACA,K;AACA,0B;AACA,K;AACA,E;;AAEA,qE;AACA,wD;AACA,0D;AACA,8D;AACA,wB;AACA,yC;AACA,2C;AACA,G;AACA,iC;AACA,E;;AAEA,+D;AACA,6B;AACA,mE;AACA,gD;AACA,8C;AACA,0C;AACA,kB;AACA,U;AACA,kE;AACA,oE;AACA,4B;AACA,yB;AACA,kB;AACA,G;AACA,E;;AAEA,2D;AACA,wC;AACA,E;;AAEA,oD;AACA,kB;AACA,gB;AACA,4D;AACA,sD;AACA,qD;AACA,qD;AACA,4B;AACA,O;AACA,K;AACA,wB;AACA,E;;AAEA,+C;AACA,+B;;AAEA,oC;AACA,6C;AACA,+B;AACA,6C;AACA,4B;AACA,6B;AACA,uC;AACA,6C;AACA,U;AACA,K;AACA,e;AACA,E;;AAEA,yE;AACA,kE;AACA,uE;AACA,gE;AACA,kB;AACA,oD;AACA,iE;AACA,gB;AACA,K;AACA,E;;AAEA,oE;AACA,mE;AACA,gD;AACA,uE;AACA,kB;AACA,iD;AACA,uD;AACA,gB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACpIA,wB;AACA,0B;;AAEA,qE;AACA,6D;AACA,gD;AACA,E;AACA,sE;AACA,oE;AACA,oE;AACA,mE;AACA,kE;AACA,iE;AACA,8D;AACA,mE;AACA,iC;;AAEA,2D;AACA,kB;;AAEA,6B;AACA,qC;;AAEA,uC;AACA,E;;AAEA,8C;AACA,E;AACA,4C;AACA,6C;AACA,E;AACA,sD;AACA,sD;AACA,4D;;AAEA,0C;AACA,qD;AACA,0D;AACA,gD;AACA,yD;AACA,uB;AACA,O;;AAEA,8C;;AAEA,2E;AACA,+D;AACA,K;AACA,E;;AAEA,qE;AACA,uD;AACA,0E;AACA,0D;AACA,8C;AACA,oD;AACA,G;;AAEA,kD;AACA,E;;AAEA,iE;AACA,kB;AACA,gC;AACA,2D;AACA,sC;AACA,8B;AACA,sD;AACA,+C;AACA,sD;AACA,K;AACA,K;AACA,E;;AAEA,yE;AACA,yB;AACA,8E;AACA,kB;;AAEA,0E;AACA,uE;AACA,wE;AACA,iD;AACA,qB;AACA,gC;;AAEA,oC;AACA,iD;AACA,2C;AACA,8B;AACA,K;AACA,I;;AAEA,+B;;AAEA,4B;AACA,kC;AACA,kC;AACA,wE;AACA,kE;AACA,+C;AACA,0B;AACA,S;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzGA,wB;AACA,0B;;AAEA,oE;AACA,wD;AACA,mB;;AAEA,qE;AACA,oE;AACA,4D;AACA,wE;AACA,kB;AACA,0B;;AAEA,qE;AACA,sE;AACA,uE;AACA,wE;AACA,qE;AACA,0C;AACA,iD;AACA,4C;AACA,e;AACA,Y;AACA,sE;AACA,K;AACA,K;;AAEA,uE;AACA,uE;AACA,mC;AACA,iC;AACA,oD;AACA,mC;AACA,6B;AACA,+B;AACA,mE;AACA,mE;AACA,2C;AACA,uC;AACA,qE;AACA,2D;AACA,0E;AACA,wC;AACA,qD;;AAEA,sC;AACA,mD;AACA,iC;AACA,qC;AACA,iE;AACA,2D;AACA,gD;AACA,wD;;AAEA,mC;AACA,6C;AACA,wE;AACA,sE;AACA,0C;AACA,wD;AACA,qC;AACA,K;AACA,wE;AACA,qD;AACA,0C;AACA,O;AACA,K;;AAEA,iD;AACA,4C;AACA,yC;AACA,mC;AACA,K;AACA,8B;AACA,yC;AACA,gC;AACA,G;;AAEA,mD;AACA,0C;AACA,kC;AACA,K;AACA,wB;AACA,qC;AACA,+B;AACA,K;AACA,E;;AAEA,uC;AACA,+B;AACA,sE;AACA,qE;AACA,oE;AACA,kD;AACA,6D;AACA,mE;AACA,oC;AACA,G;AACA,uB;AACA,wD;AACA,G;AACA,E;;AAEA,kD;AACA,yC;AACA,E;;AAEA,oD;AACA,uC;AACA,E;;AAEA,+C;AACA,oC;AACA,E;;AAEA,wD;AACA,uE;AACA,E;;AAEA,+D;AACA,kB;;AAEA,6C;;AAEA,gD;AACA,mC;AACA,K;AACA,kD;AACA,8C;AACA,K;AACA,8B;AACA,+D;AACA,qC;AACA,O;AACA,G;;AAEA,kE;AACA,iE;AACA,E;;AAEA,6C;AACA,kB;AACA,a;AACA,oC;AACA,uD;AACA,0B;AACA,O;AACA,gD;AACA,I;;AAEA,iE;AACA,wC;AACA,4B;AACA,+B;AACA,G;AACA,iD;AACA,6D;AACA,G;AACA,uC;AACA,iD;AACA,G;AACA,qC;AACA,uC;AACA,G;AACA,6C;AACA,+C;AACA,G;;AAEA,a;AACA,E;;AAEA,wC;AACA,e;AACA,2B;AACA,0B;AACA,yB;AACA,2C;AACA,+D;AACA,gE;AACA,sC;AACA,qD;AACA,4D;AACA,K;;AAEA,sB;AACA,qB;AACA,4C;AACA,6C;AACA,O;AACA,mD;AACA,K;AACA,2B;AACA,yD;AACA,6C;AACA,2D;AACA,0E;AACA,O;AACA,E;;;;;;;;;;;;;;;;;;;ACtMA,0B;AACA,wB;;AAEA,gC;AACA,kB;;AAEA,yD;AACA,oD;AACA,I;AACA,8D;AACA,gB;AACA,4C;AACA,E;;AAEA,iC;AACA,kC;AACA,+C;;AAEA,kE;AACA,oE;AACA,qE;AACA,S;AACA,E;AACA,kE;AACA,8D;AACA,oE;AACA,oE;AACA,kE;AACA,mE;AACA,oE;AACA,c;AACA,E;AACA,0D;AACA,6B;AACA,e;AACA,sE;AACA,sC;AACA,uE;AACA,+C;AACA,E;AACA,iE;AACA,mE;AACA,mB;AACA,E;AACA,gE;AACA,iE;AACA,kE;AACA,qE;AACA,mE;AACA,wC;AACA,E;AACA,+D;AACA,iE;AACA,oD;AACA,iE;AACA,4D;AACA,+D;AACA,kE;AACA,oD;AACA,E;AACA,sE;AACA,E;AACA,mE;AACA,kE;AACA,gE;AACA,gE;AACA,kE;AACA,sB;AACA,+E;AACA,kB;;AAEA,yC;AACA,uC;AACA,mD;AACA,I;;AAEA,gD;AACA,oD;;AAEA,iB;AACA,oC;AACA,2C;AACA,U;AACA,qC;AACA,uC;AACA,U;AACA,kD;AACA,yC;AACA,U;AACA,U;AACA,yC;AACA,G;;AAEA,iC;AACA,wC;AACA,mE;AACA,G;AACA,iE;AACA,oE;AACA,4D;AACA,uE;AACA,8B;;AAEA,oE;AACA,mE;AACA,qE;AACA,wE;AACA,sE;AACA,wE;AACA,6B;;AAEA,6B;AACA,kD;AACA,wB;AACA,gD;AACA,8B;AACA,2C;AACA,0E;AACA,kE;AACA,2C;AACA,uB;AACA,6C;AACA,6B;AACA,uE;AACA,sE;AACA,yE;AACA,mE;AACA,gE;AACA,a;AACA,iC;AACA,2B;AACA,W;AACA,gB;AACA,S;AACA,O;AACA,K;AACA,yC;AACA,gC;AACA,uB;AACA,yB;AACA,O;AACA,K;AACA,0C;AACA,G;AACA,4D;AACA,mE;AACA,oB;AACA,gE;AACA,yC;AACA,wE;AACA,qB;AACA,c;AACA,O;AACA,K;AACA,G;;AAEA,sE;AACA,2E;AACA,wE;AACA,oD;AACA,uC;AACA,qB;AACA,2E;AACA,4B;AACA,K;AACA,G;;AAEA,wE;AACA,2C;AACA,iC;AACA,iC;AACA,iC;AACA,iC;AACA,E;;AAEA,mE;AACA,sE;AACA,uD;AACA,0C;AACA,yB;AACA,+B;AACA,wB;AACA,8B;AACA,G;AACA,E;;AAEA,qE;AACA,2D;AACA,yD;AACA,E;AACA,uE;AACA,yE;AACA,6B;AACA,4E;AACA,kB;AACA,sC;AACA,yC;AACA,gD;AACA,6C;AACA,wB;AACA,uC;AACA,4C;AACA,4C;AACA,wB;AACA,K;AACA,0C;AACA,2B;AACA,Y;AACA,K;AACA,G;AACA,mD;AACA,uE;AACA,2D;AACA,E;;AAEA,4E;AACA,2E;AACA,8B;AACA,iE;AACA,kC;;AAEA,kB;AACA,uD;;AAEA,6E;AACA,6D;AACA,sE;AACA,sE;AACA,kC;AACA,oD;AACA,iD;AACA,gF;AACA,oE;AACA,4E;AACA,qD;AACA,8E;AACA,gF;AACA,8E;AACA,8D;;AAEA,0E;AACA,iD;AACA,oB;AACA,Q;AACA,4C;AACA,qB;AACA,G;AACA,iD;AACA,qB;AACA,G;AACA,kD;AACA,qB;AACA,G;;AAEA,U;AACA,a;AACA,8C;AACA,8C;AACA,8C;AACA,6C;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACrQA,0B;AACA,wB;;AAEA,6B;AACA,qB;AACA,E;;AAEA,6E;AACA,kE;;AAEA,uC;AACA,kB;AACA,yB;;AAEA,qB;AACA,+B;;AAEA,uC;AACA,8D;AACA,oE;AACA,4E;AACA,4C;;AAEA,+B;AACA,2D;;AAEA,kB;AACA,wB;;AAEA,qB;;AAEA,mD;AACA,mB;AACA,K;;AAEA,uD;AACA,E;;AAEA,kD;AACA,2B;AACA,qD;AACA,0B;AACA,O;AACA,mD;AACA,kC;AACA,G;AACA,E;;AAEA,sD;AACA,kB;AACA,sD;AACA,kD;AACA,U;AACA,+D;AACA,G;AACA,E;;AAEA,0E;AACA,mE;AACA,0E;AACA,mD;AACA,2C;AACA,kB;AACA,+B;AACA,yB;AACA,iC;AACA,6B;;AAEA,qC;AACA,qE;AACA,iB;;AAEA,uE;AACA,kE;AACA,mB;AACA,gC;AACA,0E;;AAEA,8D;AACA,qE;AACA,+D;AACA,uE;AACA,kE;AACA,yE;AACA,0D;AACA,I;AACA,+D;AACA,mE;AACA,iE;AACA,oE;AACA,8B;AACA,wD;AACA,sE;AACA,iD;AACA,8B;AACA,kD;AACA,e;AACA,O;AACA,oC;AACA,oD;AACA,0E;AACA,W;AACA,S;AACA,8B;AACA,+E;AACA,uC;AACA,W;AACA,O;AACA,6C;AACA,O;AACA,K;;AAEA,sC;;AAEA,yD;AACA,gC;AACA,+D;AACA,wC;;AAEA,yD;AACA,6C;AACA,sC;AACA,yC;AACA,iD;AACA,0C;AACA,uE;AACA,yC;AACA,O;AACA,O;;AAEA,uD;AACA,0C;AACA,qD;AACA,4E;AACA,S;AACA,4B;AACA,K;AACA,K;;AAEA,iC;;AAEA,qE;AACA,yE;AACA,6D;AACA,0E;AACA,a;AACA,I;AACA,uE;AACA,qE;AACA,2E;AACA,qE;AACA,iB;AACA,I;AACA,0E;AACA,0B;;AAEA,yB;AACA,kC;AACA,mE;AACA,gC;;AAEA,oC;AACA,yC;;AAEA,8C;AACA,2D;AACA,mC;AACA,+C;AACA,yC;AACA,+D;AACA,gE;AACA,gD;AACA,sD;AACA,8C;AACA,W;AACA,yD;AACA,gB;AACA,6B;AACA,0D;AACA,gC;AACA,a;AACA,W;AACA,S;AACA,S;AACA,O;AACA,I;;AAEA,oD;AACA,8C;AACA,K;;AAEA,gC;;AAEA,kC;AACA,4B;AACA,iE;AACA,mD;AACA,oD;;AAEA,mD;AACA,4B;AACA,4C;AACA,+B;AACA,2D;AACA,+C;AACA,wD;;AAEA,4D;AACA,qE;AACA,yE;AACA,S;AACA,O;AACA,O;;AAEA,oD;AACA,6D;AACA,gD;AACA,6B;AACA,6D;AACA,qC;AACA,iD;AACA,yC;AACA,uD;AACA,+D;AACA,8D;AACA,4D;AACA,W;AACA,W;AACA,S;AACA,O;AACA,K;;AAEA,iC;;AAEA,oD;AACA,sC;AACA,6D;AACA,mE;AACA,gD;AACA,uD;AACA,kE;AACA,qD;AACA,S;AACA,S;AACA,O;AACA,iE;AACA,K;AACA,E;;AAEA,yE;AACA,mE;AACA,oE;AACA,0E;AACA,qE;AACA,sE;AACA,E;AACA,yE;AACA,yB;AACA,E;AACA,yE;AACA,wC;AACA,E;AACA,yE;AACA,8B;AACA,E;AACA,uB;AACA,kD;AACA,sB;AACA,sB;AACA,yB;AACA,6C;AACA,sE;;AAEA,mB;;AAEA,a;AACA,qB;AACA,yB;AACA,4C;AACA,E;;AAEA,mE;AACA,qD;AACA,4D;AACA,uB;AACA,2C;AACA,+C;AACA,K;AACA,0B;AACA,G;AACA,mC;AACA,qB;AACA,0B;AACA,2C;AACA,oC;AACA,kE;AACA,wD;AACA,O;AACA,Y;AACA,gC;AACA,K;AACA,G;AACA,E;;AAEA,kB;;AAEA,kB;AACA,4B;AACA,2C;AACA,wD;AACA,yD;AACA,kB;;AAEA,wB;AACA,oC;AACA,gC;AACA,iC;AACA,O;AACA,W;AACA,G;;AAEA,iC;AACA,0D;AACA,iC;AACA,kC;AACA,oC;AACA,gC;AACA,2D;AACA,oC;AACA,8B;AACA,0B;AACA,K;AACA,qC;AACA,wE;AACA,qC;AACA,W;AACA,G;;AAEA,6B;;AAEA,0D;;AAEA,2B;;AAEA,0B;AACA,uC;;AAEA,gB;AACA,iD;AACA,K;;AAEA,mC;AACA,+B;;AAEA,oC;AACA,8C;AACA,2C;AACA,mC;AACA,iC;AACA,W;AACA,sB;AACA,yC;AACA,+D;AACA,a;AACA,W;AACA,U;AACA,+C;AACA,U;;AAEA,wE;AACA,gB;AACA,gD;;AAEA,yB;AACA,2C;AACA,kE;AACA,mC;AACA,+C;AACA,+C;AACA,W;AACA,W;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,sE;AACA,oE;AACA,sE;AACA,4D;AACA,kB;AACA,+B;AACA,yB;AACA,6B;AACA,sC;AACA,iE;AACA,yC;AACA,2B;AACA,K;AACA,K;AACA,uB;AACA,E;;AAEA,kE;AACA,0C;AACA,6B;AACA,K;AACA,0C;AACA,wB;AACA,4B;AACA,8C;AACA,2E;AACA,K;AACA,+C;AACA,wC;AACA,K;AACA,G;AACA,E;;AAEA,mE;AACA,sE;AACA,iD;AACA,6D;AACA,wE;AACA,sE;AACA,2D;AACA,2E;AACA,iE;AACA,kB;AACA,0D;AACA,0D;AACA,0D;AACA,wD;;AAEA,oB;AACA,mD;AACA,iB;AACA,qC;AACA,2C;AACA,oE;AACA,yE;AACA,S;AACA,O;;AAEA,qC;AACA,E;;AAEA,wC;AACA,yE;AACA,uE;AACA,wE;AACA,6B;AACA,qE;AACA,2E;AACA,sE;AACA,kB;;AAEA,gE;AACA,0D;AACA,0D;AACA,0D;AACA,wD;;AAEA,oB;AACA,oD;AACA,iB;AACA,mD;AACA,oC;AACA,4C;AACA,iD;AACA,0D;AACA,kD;AACA,iD;AACA,+D;AACA,S;AACA,O;;AAEA,+C;AACA,E;;AAEA,qD;AACA,kB;AACA,e;AACA,oD;AACA,8B;AACA,iE;AACA,kD;AACA,mB;AACA,K;AACA,K;;AAEA,sB;AACA,6B;AACA,wC;AACA,sE;AACA,iE;AACA,4C;AACA,K;AACA,wC;AACA,K;;AAEA,oB;AACA,E;;AAEA,4E;AACA,kC;AACA,uD;AACA,kB;AACA,2B;AACA,wB;AACA,mD;AACA,G;AACA,8C;AACA,E;;AAEA,oD;AACA,kB;AACA,4D;AACA,oC;AACA,K;AACA,E;;AAEA,qD;AACA,kB;AACA,yB;AACA,+B;AACA,iC;AACA,gE;AACA,6B;;AAEA,Y;AACA,mE;AACA,4C;AACA,K;;AAEA,8B;AACA,yD;AACA,6C;AACA,uB;AACA,O;AACA,K;;AAEA,qE;AACA,0D;AACA,6D;AACA,+D;AACA,oD;AACA,8C;AACA,qD;AACA,mC;AACA,kE;AACA,oD;AACA,wE;AACA,6D;AACA,6D;AACA,O;AACA,O;AACA,K;;AAEA,4C;AACA,gE;AACA,6D;AACA,gD;AACA,6D;AACA,qC;AACA,6B;AACA,mD;AACA,0D;AACA,W;AACA,W;AACA,S;AACA,O;AACA,K;;AAEA,wE;AACA,mD;AACA,oD;AACA,+C;AACA,qE;AACA,yE;AACA,gD;AACA,oE;AACA,0E;AACA,oB;AACA,+B;AACA,uD;AACA,yE;AACA,O;AACA,K;;AAEA,qE;AACA,sE;AACA,4D;AACA,0D;AACA,qE;AACA,oE;AACA,mE;AACA,I;AACA,qE;AACA,gE;AACA,mE;AACA,yC;AACA,uE;AACA,sC;AACA,kE;;AAEA,yC;AACA,oC;AACA,K;AACA,sD;AACA,6D;AACA,+D;AACA,qD;AACA,a;;AAEA,uE;AACA,iE;AACA,kE;AACA,4B;AACA,yE;AACA,0E;AACA,0D;AACA,wB;AACA,sC;AACA,wB;AACA,c;AACA,yB;AACA,iE;AACA,8C;AACA,mD;AACA,2B;AACA,O;AACA,O;AACA,0B;AACA,K;;AAEA,oE;AACA,uE;AACA,qE;AACA,8B;AACA,sE;;AAEA,sE;AACA,uE;AACA,kD;AACA,oE;AACA,kE;AACA,oD;AACA,0E;AACA,2C;;AAEA,uD;AACA,4C;AACA,mD;;AAEA,uD;AACA,uD;AACA,sC;AACA,kD;AACA,iE;AACA,4D;;AAEA,uD;AACA,kD;AACA,K;;AAEA,wC;AACA,mE;AACA,iE;AACA,qE;AACA,qC;AACA,yE;AACA,oD;AACA,4D;AACA,sE;AACA,yD;AACA,a;AACA,S;AACA,S;AACA,O;;AAEA,6E;AACA,iF;AACA,kF;AACA,e;AACA,wC;AACA,G;;AAEA,yC;AACA,uD;;AAEA,sC;AACA,+E;AACA,8E;AACA,4E;AACA,wC;AACA,G;;AAEA,0C;;AAEA,8E;AACA,0C;AACA,qB;AACA,uB;AACA,oD;AACA,kC;AACA,K;;AAEA,6C;AACA,uC;AACA,4C;;AAEA,+D;AACA,2C;AACA,K;;AAEA,yC;AACA,4D;;AAEA,yE;AACA,yE;AACA,mE;AACA,0E;AACA,6E;AACA,I;AACA,6E;AACA,uE;AACA,uE;AACA,wE;AACA,8E;AACA,qE;AACA,2E;AACA,6E;AACA,4E;AACA,yE;AACA,yE;AACA,yE;AACA,gF;AACA,sD;AACA,4D;AACA,4D;AACA,4C;AACA,gD;AACA,uC;AACA,iE;AACA,O;AACA,O;AACA,K;;AAEA,mD;AACA,yB;AACA,2D;AACA,uC;AACA,2C;AACA,mC;AACA,4B;AACA,K;AACA,K;;AAEA,yC;AACA,kC;AACA,iD;;AAEA,sE;;AAEA,wC;AACA,yD;AACA,qE;AACA,6D;AACA,0E;AACA,yC;AACA,S;AACA,kD;AACA,6E;AACA,4C;AACA,W;AACA,+C;AACA,yC;AACA,6C;AACA,W;AACA,mC;AACA,S;AACA,O;AACA,0B;AACA,G;;AAEA,iC;AACA,kD;AACA,0B;AACA,G;;AAEA,0C;AACA,+D;AACA,4E;AACA,0E;AACA,uE;AACA,uE;AACA,+D;AACA,mD;;AAEA,8E;AACA,8B;AACA,oD;AACA,wD;AACA,8E;AACA,4C;AACA,gF;AACA,+D;AACA,2B;AACA,4D;AACA,wC;AACA,sD;AACA,yD;AACA,4B;AACA,S;AACA,S;AACA,4B;AACA,yB;AACA,qE;AACA,wE;AACA,oC;AACA,O;AACA,O;AACA,0B;AACA,G;;AAEA,gB;AACA,0C;AACA,iE;AACA,8D;AACA,sC;AACA,M;AACA,I;;AAEA,mB;AACA,sD;AACA,2C;AACA,oC;AACA,iD;AACA,kE;AACA,0B;AACA,wC;AACA,gC;AACA,S;AACA,2B;AACA,Q;AACA,4B;AACA,sD;AACA,O;AACA,yC;AACA,O;AACA,I;;AAEA,gB;AACA,E;;AAEA,2E;AACA,uE;AACA,uD;AACA,8D;AACA,iC;AACA,Y;AACA,kB;AACA,K;AACA,M;AACA,E;;AAEA,+D;AACA,gE;AACA,+D;AACA,kB;;AAEA,mD;AACA,yE;;AAEA,oD;AACA,sB;AACA,U;AACA,sD;AACA,G;AACA,E;;AAEA,mE;AACA,kB;AACA,8C;;AAEA,2D;;AAEA,oC;AACA,kC;AACA,gB;AACA,sB;AACA,8C;AACA,sD;AACA,c;AACA,gC;AACA,O;AACA,qC;AACA,qD;AACA,oE;AACA,S;AACA,K;AACA,K;;AAEA,gB;AACA,E;;AAEA,kD;AACA,kB;;AAEA,+B;AACA,8C;;AAEA,mE;AACA,sC;AACA,oC;AACA,6C;AACA,kC;AACA,6D;AACA,mE;AACA,0D;AACA,W;AACA,8B;AACA,yE;AACA,2E;AACA,+D;AACA,S;AACA,qB;AACA,8D;AACA,0C;AACA,+E;;AAEA,mE;;AAEA,gC;AACA,O;AACA,O;AACA,K;;AAEA,iC;AACA,wB;;AAEA,sE;AACA,E;;AAEA,4E;AACA,sE;AACA,iE;AACA,uE;AACA,sD;AACA,qE;AACA,E;AACA,sE;AACA,qE;AACA,gD;AACA,6E;AACA,iD;AACA,kB;AACA,yB;AACA,iC;AACA,+B;;AAEA,4C;AACA,kC;AACA,mE;AACA,iE;AACA,I;AACA,uC;;AAEA,mD;AACA,6C;AACA,gB;AACA,K;AACA,6B;;AAEA,0C;AACA,oB;AACA,K;;AAEA,yD;AACA,wC;;AAEA,mB;AACA,8B;;AAEA,sC;AACA,8C;AACA,iC;AACA,+B;AACA,+D;AACA,sE;AACA,0C;AACA,oE;AACA,gC;AACA,4C;AACA,W;AACA,W;AACA,O;AACA,O;;AAEA,iB;AACA,I;;AAEA,yC;AACA,E;;;AAGA,gF;AACA,yB;AACA,6B;AACA,iC;AACA,iC;;AAEA,iE;AACA,yB;AACA,iD;AACA,gD;AACA,gD;AACA,kC;AACA,E;;;;;;;;;;;;;;;;;;;AC3/BA,wB;AACA,0B;;AAEA,uE;AACA,wE;;AAEA,mD;AACA,kB;;AAEA,yB;AACA,4C;AACA,6E;;AAEA,mB;AACA,oC;AACA,uC;AACA,I;AACA,E;;AAEA,mE;AACA,kD;AACA,W;AACA,4E;AACA,kC;AACA,gF;AACA,wC;AACA,2E;AACA,2E;AACA,0E;AACA,0C;AACA,0D;AACA,yE;AACA,6C;AACA,yE;AACA,0C;AACA,4E;AACA,kD;AACA,4E;AACA,4D;AACA,kB;AACA,0B;AACA,2D;;AAEA,Y;AACA,4C;AACA,sE;AACA,wC;AACA,0C;AACA,yD;AACA,mD;AACA,0D;AACA,oE;AACA,K;;AAEA,e;AACA,qC;AACA,iB;AACA,gD;AACA,O;;AAEA,0E;AACA,wE;AACA,oE;AACA,uE;AACA,wC;AACA,0E;AACA,S;AACA,S;AACA,O;AACA,G;;AAEA,uD;AACA,+B;AACA,kC;AACA,K;AACA,E;;AAEA,qB;AACA,E;AACA,0B;AACA,gF;AACA,6E;AACA,+C;AACA,2D;AACA,mE;AACA,0B;;AAEA,wB;AACA,4D;AACA,8C;AACA,6D;AACA,G;;AAEA,a;AACA,0E;AACA,mC;AACA,2B;AACA,8B;AACA,O;AACA,K;;AAEA,yE;AACA,iD;AACA,mC;AACA,oC;AACA,O;AACA,qE;AACA,mB;AACA,kB;AACA,K;AACA,E;;;AAGA,iC;AACA,kE;AACA,qD;AACA,4B;AACA,qE;AACA,uE;AACA,qC;;AAEA,oC;AACA,kB;AACA,oC;AACA,oD;AACA,oC;AACA,4C;AACA,wD;AACA,gC;;AAEA,uE;AACA,0C;AACA,+B;AACA,qB;AACA,O;;AAEA,4E;AACA,gB;AACA,iC;AACA,qB;AACA,O;;AAEA,kB;AACA,Y;AACA,sD;AACA,K;AACA,K;AACA,E;;AAEA,oD;AACA,6B;AACA,iC;AACA,U;AACA,E;;AAEA,iE;AACA,Y;AACA,wC;AACA,W;AACA,E;AACA,6C;AACA,a;AACA,E","file":"/packages/constraint-solver.js","sourcesContent":["ConstraintSolver = {};\n\nvar PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n////////// PackageAndVersion\n\n// An ordered pair of (package, version).\nCS.PackageAndVersion = function (package, version) {\n  check(package, String);\n  check(version, String);\n\n  this.package = package;\n  this.version = version;\n};\n\n// The string form of a PackageAndVersion is \"package version\",\n// for example \"foo 1.0.1\".  The reason we don't use an \"@\" is\n// it would look too much like a PackageConstraint.\nCS.PackageAndVersion.prototype.toString = function () {\n  return this.package + \" \" + this.version;\n};\n\nCS.PackageAndVersion.fromString = function (str) {\n  var parts = str.split(' ');\n  if (parts.length === 2 && parts[0] && parts[1]) {\n    return new CS.PackageAndVersion(parts[0], parts[1]);\n  } else {\n    throw new Error(\"Malformed PackageAndVersion: \" + str);\n  }\n};\n\n////////// Dependency\n\n// A Dependency consists of a PackageConstraint (like \"foo@=1.2.3\")\n// and flags, like \"isWeak\".\n\nCS.Dependency = function (packageConstraint, flags) {\n  if (typeof packageConstraint !== 'string') {\n    // this `if` is because Match.OneOf is really, really slow when it fails\n    check(packageConstraint, Match.OneOf(PV.PackageConstraint, String));\n  }\n  if (typeof packageConstraint === 'string') {\n    packageConstraint = PV.parsePackageConstraint(packageConstraint);\n  }\n  if (flags) {\n    check(flags, Object);\n  }\n\n  this.packageConstraint = packageConstraint;\n  this.isWeak = false;\n\n  if (flags) {\n    if (flags.isWeak) {\n      this.isWeak = true;\n    }\n  }\n};\n\n// The string form of a Dependency is `?foo@1.0.0` for a weak\n// reference to package \"foo\" with VersionConstraint \"1.0.0\".\nCS.Dependency.prototype.toString = function () {\n  var ret = this.packageConstraint.toString();\n  if (this.isWeak) {\n    ret = '?' + ret;\n  }\n  return ret;\n};\n\nCS.Dependency.fromString = function (str) {\n  var isWeak = false;\n\n  if (str.charAt(0) === '?') {\n    isWeak = true;\n    str = str.slice(1);\n  }\n\n  var flags = isWeak ? { isWeak: true } : null;\n\n  return new CS.Dependency(str, flags);\n};\n","var CS = ConstraintSolver;\nvar PV = PackageVersion;\n\nvar pvkey = function (package, version) {\n  return package + \" \" + version;\n};\n\n// Stores the Dependencies for each known PackageAndVersion.\nCS.CatalogCache = function () {\n  // String(PackageAndVersion) -> String -> Dependency.\n  // For example, \"foo 1.0.0\" -> \"bar\" -> Dependency.fromString(\"?bar@1.0.2\").\n  this._dependencies = {};\n  // A map derived from the keys of _dependencies, for ease of iteration.\n  // \"foo\" -> [\"1.0.0\", ...]\n  // Versions in the array are unique but not sorted, unless the `.sorted`\n  // property is set on the array.  The array is never empty.\n  this._versions = {};\n};\n\nCS.CatalogCache.prototype.hasPackageVersion = function (package, version) {\n  return _.has(this._dependencies, pvkey(package, version));\n};\n\nCS.CatalogCache.prototype.addPackageVersion = function (p, v, deps) {\n  check(p, String);\n  check(v, String);\n  // `deps` must not have any duplicate values of `.packageConstraint.package`\n  check(deps, [CS.Dependency]);\n\n  var key = pvkey(p, v);\n  if (_.has(this._dependencies, key)) {\n    throw new Error(\"Already have an entry for \" + key);\n  }\n\n  if (! _.has(this._versions, p)) {\n    this._versions[p] = [];\n  }\n  this._versions[p].push(v);\n  this._versions[p].sorted = false;\n\n  var depsByPackage = {};\n  this._dependencies[key] = depsByPackage;\n  _.each(deps, function (d) {\n    var p2 = d.packageConstraint.package;\n    if (_.has(depsByPackage, p2)) {\n      throw new Error(\"Can't have two dependencies on \" + p2 +\n                      \" in \" + key);\n    }\n    depsByPackage[p2] = d;\n  });\n};\n\n// Returns the dependencies of a (package, version), stored in a map.\n// The values are Dependency objects; the key for `d` is\n// `d.packageConstraint.package`.  (Don't mutate the map.)\nCS.CatalogCache.prototype.getDependencyMap = function (p, v) {\n  var key = pvkey(p, v);\n  if (! _.has(this._dependencies, key)) {\n    throw new Error(\"No entry for \" + key);\n  }\n  return this._dependencies[key];\n};\n\n// Returns an array of version strings, sorted, possibly empty.\n// (Don't mutate the result.)\nCS.CatalogCache.prototype.getPackageVersions = function (package) {\n  var result = (_.has(this._versions, package) ?\n                this._versions[package] : []);\n  if ((!result.length) || result.sorted) {\n    return result;\n  } else {\n    // sort in place, and record so that we don't sort redundantly\n    // (we'll sort again if more versions are pushed onto the array)\n    result.sort(PV.compare);\n    result.sorted = true;\n    return result;\n  }\n};\n\nCS.CatalogCache.prototype.hasPackage = function (package) {\n  return _.has(this._versions, package);\n};\n\nCS.CatalogCache.prototype.toJSONable = function () {\n  var self = this;\n  var data = {};\n  _.each(self._dependencies, function (depsByPackage, key) {\n    // depsByPackage is a map of String -> Dependency.\n    // Map over the values to get an array of String.\n    data[key] = _.map(depsByPackage, function (dep) {\n      return dep.toString();\n    });\n  });\n  return { data: data };\n};\n\nCS.CatalogCache.fromJSONable = function (obj) {\n  check(obj, { data: Object });\n\n  var cache = new CS.CatalogCache();\n  _.each(obj.data, function (depsArray, pv) {\n    check(depsArray, [String]);\n    pv = CS.PackageAndVersion.fromString(pv);\n    cache.addPackageVersion(\n      pv.package, pv.version,\n      _.map(depsArray, function (str) {\n        return CS.Dependency.fromString(str);\n      }));\n  });\n  return cache;\n};\n\n// Calls `iter` on each PackageAndVersion, with the second argument being\n// a map from package name to Dependency.  If `iter` returns true,\n// iteration is stopped.  There's no particular order to the iteration.\nCS.CatalogCache.prototype.eachPackageVersion = function (iter) {\n  var self = this;\n  _.find(self._dependencies, function (value, key) {\n    var stop = iter(CS.PackageAndVersion.fromString(key), value);\n    return stop;\n  });\n};\n\n// Calls `iter` on each package name, with the second argument being\n// a list of versions present for that package (unique and sorted).\n// If `iter` returns true, iteration is stopped.\nConstraintSolver.CatalogCache.prototype.eachPackage = function (iter) {\n  var self = this;\n  _.find(_.keys(self._versions), function (key) {\n    var stop = iter(key, self.getPackageVersions(key));\n    return stop;\n  });\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// A CatalogLoader populates the CatalogCache from the Catalog.  When\n// running unit tests with no Catalog and canned data for the\n// CatalogCache, there will be no CatalogLoader.\n//\n// Fine-grained Loading: While we don't currently support loading only\n// some versions of a package, CatalogLoader is meant to be extended\n// to support incrementally loading individual package versions.  It\n// has no concept of a \"loaded package,\" for example, just a loaded\n// package version.  CatalogLoader's job, in principle, is to load\n// package versions efficiently, no matter the access pattern, by\n// making the right catalog calls and doing the right caching.\n// Calling a catalog method generally means running a SQLite query,\n// which could be time-consuming.\n\nCS.CatalogLoader = function (fromCatalog, toCatalogCache) {\n  var self = this;\n\n  self.catalog = fromCatalog;\n  self.catalogCache = toCatalogCache;\n\n  self._sortedVersionRecordsCache = {};\n};\n\n// We rely on the following `catalog` methods:\n//\n// * getSortedVersionRecords(packageName) ->\n//     [{packageName, version, dependencies}]\n//\n//   Where `dependencies` is a map from packageName to\n//   an object of the form `{ constraint: String|null,\n//   references: [{arch: String, optional \"weak\": true}] }`.\n\nvar convertDeps = function (catalogDeps) {\n  return _.map(catalogDeps, function (dep, package) {\n    // The dependency is strong if any of its \"references\"\n    // (for different architectures) are strong.\n    var isStrong = _.any(dep.references, function (ref) {\n      return !ref.weak;\n    });\n\n    var constraint = (dep.constraint || null);\n\n    return new CS.Dependency(new PV.PackageConstraint(package, constraint),\n                             isStrong ? null : {isWeak: true});\n  });\n};\n\n// Since we don't fetch different versions of a package independently\n// at the moment, this helper is where we get our data.\nCS.CatalogLoader.prototype._getSortedVersionRecords = function (package) {\n  if (! _.has(this._sortedVersionRecordsCache, package)) {\n    this._sortedVersionRecordsCache[package] =\n      this.catalog.getSortedVersionRecords(package);\n  }\n\n  return this._sortedVersionRecordsCache[package];\n};\n\nCS.CatalogLoader.prototype.loadAllVersions = function (package) {\n  var self = this;\n  var cache = self.catalogCache;\n  var versionRecs = self._getSortedVersionRecords(package);\n  _.each(versionRecs, function (rec) {\n    var version = rec.version;\n    if (! cache.hasPackageVersion(package, version)) {\n      var deps = convertDeps(rec.dependencies);\n      cache.addPackageVersion(package, version, deps);\n    }\n  });\n};\n\n// Takes an array of package names.  Loads all versions of them and their\n// (strong) dependencies.\nCS.CatalogLoader.prototype.loadAllVersionsRecursive = function (packageList) {\n  var self = this;\n\n  // Within a call to loadAllVersionsRecursive, we only visit each package\n  // at most once.  If we visit a package we've already loaded, it will\n  // lead to a quick scan through the versions in our cache to make sure\n  // they have been loaded into the CatalogCache.\n  var loadQueue = [];\n  var packagesEverEnqueued = {};\n\n  var enqueue = function (package) {\n    if (! _.has(packagesEverEnqueued, package)) {\n      packagesEverEnqueued[package] = true;\n      loadQueue.push(package);\n    }\n  };\n\n  _.each(packageList, enqueue);\n\n  while (loadQueue.length) {\n    var package = loadQueue.pop();\n    self.loadAllVersions(package);\n    _.each(self.catalogCache.getPackageVersions(package), function (v) {\n      var depMap = self.catalogCache.getDependencyMap(package, v);\n      _.each(depMap, function (dep, package2) {\n        enqueue(package2);\n      });\n    });\n  }\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// `check` can be really slow, so this line is a valve that makes it\n// easy to turn off when debugging performance problems.\nvar _check = check;\n\n// The \"Input\" object completely specifies the input to the resolver,\n// and it holds the data loaded from the Catalog as well.  It can be\n// serialized to JSON and read back in for testing purposes.\nCS.Input = function (dependencies, constraints, catalogCache, options) {\n  var self = this;\n  options = options || {};\n\n  // PackageConstraints passed in from the tool to us (where we are a\n  // uniloaded package) will have constructors that we don't recognize\n  // because they come from a different copy of package-version-parser!\n  // Convert them to our PackageConstraint class if necessary.  (This is\n  // just top-level constraints from .meteor/packages or running from\n  // checkout, so it's not a lot of data.)\n  constraints = _.map(constraints, function (c) {\n    if (c instanceof PV.PackageConstraint) {\n      return c;\n    } else {\n      return PV.parsePackageConstraint(c.package, c.constraintString);\n    }\n  });\n\n  // Note that `dependencies` and `constraints` are required (you can't\n  // omit them or pass null), while the other properties have defaults.\n  self.dependencies = dependencies;\n  self.constraints = constraints;\n  // If you add a property, make sure you add it to:\n  // - The `check` statements below\n  // - toJSONable (this file)\n  // - fromJSONable (this file)\n  // - the \"input serialization\" test in constraint-solver-tests.js\n  // If it's an option passed in from the tool, you'll also have to\n  // add it to CS.PackagesResolver#resolve.\n  self.upgrade = options.upgrade || [];\n  self.anticipatedPrereleases = options.anticipatedPrereleases || {};\n  self.previousSolution = options.previousSolution || null;\n  self.allowIncompatibleUpdate = options.allowIncompatibleUpdate || false;\n  self.upgradeIndirectDepPatchVersions =\n    options.upgradeIndirectDepPatchVersions || false;\n\n  _check(self.dependencies, [String]);\n  _check(self.constraints, [PV.PackageConstraint]);\n  _check(self.upgrade, [String]);\n  _check(self.anticipatedPrereleases,\n        Match.ObjectWithValues(Match.ObjectWithValues(Boolean)));\n  _check(self.previousSolution, Match.OneOf(Object, null));\n  _check(self.allowIncompatibleUpdate, Boolean);\n  _check(self.upgradeIndirectDepPatchVersions, Boolean);\n\n  self.catalogCache = catalogCache;\n  _check(self.catalogCache, CS.CatalogCache);\n  // The catalog presumably has valid package names in it, but make sure\n  // there aren't any characters in there somehow that will trip us up\n  // with creating valid variable strings.\n  self.catalogCache.eachPackage(function (packageName) {\n    validatePackageName(packageName);\n  });\n  self.catalogCache.eachPackageVersion(function (packageName, depsMap) {\n    _.each(depsMap, function (deps, depPackageName) {\n      validatePackageName(depPackageName);\n    });\n  });\n\n  _.each(self.dependencies, validatePackageName);\n  _.each(self.upgrade, validatePackageName);\n  _.each(self.constraints, function (c) {\n    validatePackageName(c.package);\n  });\n  if (self.previousSolution) {\n    _.each(_.keys(self.previousSolution),\n           validatePackageName);\n  }\n\n  self._dependencySet = {}; // package name -> true\n  _.each(self.dependencies, function (d) {\n    self._dependencySet[d] = true;\n  });\n  self._upgradeSet = {};\n  _.each(self.upgrade, function (u) {\n    self._upgradeSet[u] = true;\n  });\n};\n\nvalidatePackageName = function (name) {\n  PV.validatePackageName(name);\n  // We have some hard requirements of our own so that packages can be\n  // used as solver variables.  PV.validatePackageName should already\n  // enforce these requirements and more, so these checks are just a\n  // backstop in case it changes under us somehow.\n  if ((name.charAt(0) === '$') || (name.charAt(0) === '-')) {\n    throw new Error(\"First character of package name cannot be: \" +\n                    name.charAt(0));\n  }\n  if (/ /.test(name)) {\n    throw new Error(\"No space allowed in package name\");\n  }\n};\n\nCS.Input.prototype.isKnownPackage = function (p) {\n  return this.catalogCache.hasPackage(p);\n};\n\nCS.Input.prototype.isRootDependency = function (p) {\n  return _.has(this._dependencySet, p);\n};\n\nCS.Input.prototype.isUpgrading = function (p) {\n  return _.has(this._upgradeSet, p);\n};\n\nCS.Input.prototype.isInPreviousSolution = function (p) {\n  return !! (this.previousSolution && _.has(this.previousSolution, p));\n};\n\nCS.Input.prototype.loadFromCatalog = function (catalogLoader) {\n  var self = this;\n\n  var packagesToLoad = {}; // package -> true\n\n  _.each(self.dependencies, function (package) {\n    packagesToLoad[package] = true;\n  });\n  _.each(self.constraints, function (constraint) {\n    packagesToLoad[constraint.package] = true;\n  });\n  if (self.previousSolution) {\n    _.each(self.previousSolution, function (version, package) {\n      packagesToLoad[package] = true;\n    });\n  }\n\n  // Load packages into the cache (if they aren't loaded already).\n  catalogLoader.loadAllVersionsRecursive(_.keys(packagesToLoad));\n};\n\nCS.Input.prototype.toJSONable = function () {\n  var self = this;\n  var obj = {\n    dependencies: self.dependencies,\n    constraints: _.map(self.constraints, function (c) {\n      return c.toString();\n    }),\n    catalogCache: self.catalogCache.toJSONable()\n  };\n\n  // For readability of the resulting JSON, only include optional\n  // properties that aren't the default.\n  if (self.upgrade.length) {\n    obj.upgrade = self.upgrade;\n  }\n  if (! _.isEmpty(self.anticipatedPrereleases)) {\n    obj.anticipatedPrereleases = self.anticipatedPrereleases;\n  }\n  if (self.previousSolution !== null) {\n    obj.previousSolution = self.previousSolution;\n  }\n  if (self.allowIncompatibleUpdate) {\n    obj.allowIncompatibleUpdate = true;\n  }\n  if (self.upgradeIndirectDepPatchVersions) {\n    obj.upgradeIndirectDepPatchVersions = true;\n  }\n\n  return obj;\n};\n\nCS.Input.fromJSONable = function (obj) {\n  _check(obj, {\n    dependencies: [String],\n    constraints: [String],\n    catalogCache: Object,\n    anticipatedPrereleases: Match.Optional(\n      Match.ObjectWithValues(Match.ObjectWithValues(Boolean))),\n    previousSolution: Match.Optional(Match.OneOf(Object, null)),\n    upgrade: Match.Optional([String]),\n    allowIncompatibleUpdate: Match.Optional(Boolean),\n    upgradeIndirectDepPatchVersions: Match.Optional(Boolean)\n  });\n\n  return new CS.Input(\n    obj.dependencies,\n    _.map(obj.constraints, function (cstr) {\n      return PV.parsePackageConstraint(cstr);\n    }),\n    CS.CatalogCache.fromJSONable(obj.catalogCache),\n    {\n      upgrade: obj.upgrade,\n      anticipatedPrereleases: obj.anticipatedPrereleases,\n      previousSolution: obj.previousSolution,\n      allowIncompatibleUpdate: obj.allowIncompatibleUpdate,\n      upgradeIndirectDepPatchVersions: obj.upgradeIndirectDepPatchVersions\n    });\n};\n","var CS = ConstraintSolver;\nvar PV = PackageVersion;\n\nCS.VersionPricer = function () {\n  var self = this;\n\n  // self.getVersionInfo(versionString) returns an object\n  // that contains at least { major, minor, patch }.\n  //\n  // The VersionPricer instance stores a memoization table for\n  // efficiency.\n  self.getVersionInfo = _.memoize(PV.parse);\n};\n\nCS.VersionPricer.MODE_UPDATE = 1;\nCS.VersionPricer.MODE_GRAVITY = 2;\nCS.VersionPricer.MODE_GRAVITY_WITH_PATCHES = 3;\n\n// priceVersions(versions, mode, options) calculates small integer\n// costs for each version, based on whether each part of the version\n// is low or high relative to the other versions with the same higher\n// parts.\n//\n// For example, if \"1.2.0\" and \"1.2.1\" are the only 1.2.x versions\n// in the versions array, they will be assigned PATCH costs of\n// 1 and 0 in UPDATE mode (penalizing the older version), or 0 and 1\n// in GRAVITY mode (penalizing the newer version).  When optimizing,\n// the solver will prioritizing minimizing MAJOR costs, then MINOR\n// costs, then PATCH costs, and then \"REST\" costs (which penalizing\n// being old or new within versions that have the same major, minor,\n// AND patch).\n//\n// - `versions` - Array of version strings in sorted order\n// - `mode` - A MODE constant\n// - `options`:\n//   - `versionAfter` - if provided, the next newer version not in the\n//     array but that would come next.\n//   - `versionBefore` - if provided, the next older version not in the\n//     the array but that would come before it.\n//\n// Returns: an array of 4 arrays, each of length versions.length,\n// containing the MAJOR, MINOR, PATCH, and REST costs corresponding\n// to the versions.\n//\n// MODE_UPDATE penalizes versions for being old (because we want\n// them to be new), while the MODE_GRAVITY penalizes versions for\n// being new (because we are trying to apply \"version gravity\" and\n// prefer older versions).  MODE_GRAVITY_WITH_PATCHES applies gravity\n// to the major and minor parts of the version, but prefers updates\n// to the patch and rest of the version.\n//\n// Use `versionAfter` when scanning a partial array of versions\n// if you want the newest version in the array to have a non-zero\n// weight in MODE_UPDATE.  For example, the versions\n// `[\"1.0.0\", \"1.0.1\"]` will be considered to have an out-of-date\n// version if versionAfter is `\"2.0.0\"`.  The costs returned\n// won't be the same as if the whole array was scanned at once,\n// but this option is useful in order to apply MODE_UPDATE to some\n// versions and MODE_GRAVITY to others, for example.\n//\n// `versionBefore` is used in an analogous way with the GRAVITY modes.\n//\n// The easiest way to implement this function would be to partition\n// `versions` into subarrays of versions with the same major part,\n// and then partition those arrays based on the minor parts, and\n// so on.  However, that's a lot of array allocations -- O(N) or\n// thereabouts.  So instead we use a linear scan backwards through\n// the versions array.\nCS.VersionPricer.prototype.priceVersions = function (versions, mode, options) {\n  var self = this;\n\n  var getMajorMinorPatch = function (v) {\n    var vInfo = self.getVersionInfo(v);\n    return [vInfo.major, vInfo.minor, vInfo.patch];\n  };\n\n  var MAJOR = 0, MINOR = 1, PATCH = 2, REST = 3;\n  var gravity; // array of MAJOR, MINOR, PATCH, REST\n\n  switch (mode) {\n  case CS.VersionPricer.MODE_UPDATE:\n    gravity = [false, false, false, false];\n    break;\n  case CS.VersionPricer.MODE_GRAVITY:\n    gravity = [true, true, true, true];\n    break;\n  case CS.VersionPricer.MODE_GRAVITY_WITH_PATCHES:\n    gravity = [true, true, false, false];\n    break;\n  default:\n    throw new Error(\"Bad mode: \" + mode);\n  }\n\n  var lastMajorMinorPatch = null;\n  if (options && options.versionAfter) {\n    lastMajorMinorPatch = getMajorMinorPatch(options.versionAfter);\n  }\n  // `costs` contains arrays of whole numbers, each of which will\n  // have a length of versions.length.  This is what we will return.\n  var costs = [[], [], [], []]; // MAJOR, MINOR, PATCH, REST\n  // How many in a row of the same MAJOR, MINOR, or PATCH have we seen?\n  var countOfSame = [0, 0, 0];\n\n  // Track how old each part of versions[i] is, in terms of how many\n  // greater values there are for that part among versions with the\n  // same higher parts.  For example, oldness[REST] counts the number\n  // of versions after versions[i] with the same MAJOR, MINOR, and REST.\n  // oldness[PATCH] counts the number of *different* higher values for\n  // for PATCH among later versions with the same MAJOR and MINOR parts.\n  var oldness = [0, 0, 0, 0];\n\n  // Walk the array backwards\n  for (var i = versions.length - 1; i >= 0; i--) {\n    var v = versions[i];\n    var majorMinorPatch = getMajorMinorPatch(v);\n    if (lastMajorMinorPatch) {\n      for (var k = MAJOR; k <= REST; k++) {\n        if (k === REST || majorMinorPatch[k] !== lastMajorMinorPatch[k]) {\n          // For the highest part that changed, bumped the oldness\n          // and clear the lower oldnesses.\n          oldness[k]++;\n          for (var m = k+1; m <= REST; m++) {\n            if (gravity[m]) {\n              // if we should actually be counting \"newness\" instead of\n              // oldness, flip the count.  Instead of [0, 1, 1, 2, 3],\n              // for example, make it [3, 2, 2, 1, 0].  This is the place\n              // to do it, because we have just \"closed out\" a run.\n              flipLastN(costs[m], countOfSame[m-1], oldness[m]);\n            }\n            countOfSame[m-1] = 0;\n            oldness[m] = 0;\n          }\n          break;\n        }\n      }\n    }\n    for (var k = MAJOR; k <= REST; k++) {\n      costs[k].push(oldness[k]);\n      if (k !== REST) {\n        countOfSame[k]++;\n      }\n    }\n    lastMajorMinorPatch = majorMinorPatch;\n  }\n  if (options && options.versionBefore && versions.length) {\n    // bump the appropriate value of oldness, as if we ran the loop\n    // one more time\n    majorMinorPatch = getMajorMinorPatch(options.versionBefore);\n    for (var k = MAJOR; k <= REST; k++) {\n      if (k === REST || majorMinorPatch[k] !== lastMajorMinorPatch[k]) {\n        oldness[k]++;\n        break;\n      }\n    }\n  }\n\n  // Flip the MAJOR costs if we have MAJOR gravity -- subtracting them\n  // all from oldness[MAJOR] -- and likewise for other parts if countOfSame\n  // is > 0 for the next highest part (meaning we didn't get a chance to\n  // flip some of the costs because the loop ended).\n  for (var k = MAJOR; k <= REST; k++) {\n    if (gravity[k]) {\n      flipLastN(costs[k], k === MAJOR ? costs[k].length : countOfSame[k-1],\n                oldness[k]);\n    }\n  }\n\n  // We pushed costs onto the arrays in reverse order.  Reverse the cost\n  // arrays in place before returning them.\n  return [costs[MAJOR].reverse(),\n          costs[MINOR].reverse(),\n          costs[PATCH].reverse(),\n          costs[REST].reverse()];\n};\n\n// \"Flip\" the last N elements of array in place by subtracting each\n// one from `max`.  For example, if `a` is `[3,0,1,1,2]`, then calling\n// `flipLastN(a, 4, 2)` mutates `a` into `[3,2,1,1,0]`.\nvar flipLastN = function (array, N, max) {\n  var len = array.length;\n  for (var i = 0; i < N; i++) {\n    var j = len - 1 - i;\n    array[j] = max - array[j];\n  }\n};\n\n// Partition a sorted array of versions into three arrays, containing\n// the versions that are `older` than the `target` version,\n// `compatible` with it, or have a `higherMajor` version.\n//\n// For example, `[\"1.0.0\", \"2.5.0\", \"2.6.1\", \"3.0.0\"]` with a target of\n// `\"2.5.0\"` returns `{ older: [\"1.0.0\"], compatible: [\"2.5.0\", \"2.6.1\"],\n// higherMajor: [\"3.0.0\"] }`.\nCS.VersionPricer.prototype.partitionVersions = function (versions, target) {\n  var self = this;\n  var firstGteIndex = versions.length;\n  var higherMajorIndex = versions.length;\n  var targetVInfo = self.getVersionInfo(target);\n  for (var i = 0; i < versions.length; i++) {\n    var v = versions[i];\n    var vInfo = self.getVersionInfo(v);\n    if (firstGteIndex === versions.length &&\n        ! PV.lessThan(vInfo, targetVInfo)) {\n      firstGteIndex = i;\n    }\n    if (vInfo.major > targetVInfo.major) {\n      higherMajorIndex = i;\n      break;\n    }\n  }\n  return { older: versions.slice(0, firstGteIndex),\n           compatible: versions.slice(firstGteIndex, higherMajorIndex),\n           higherMajor: versions.slice(higherMajorIndex) };\n};\n\n// Use a combination of calls to priceVersions with different modes in order\n// to generate costs for versions relative to a \"previous solution\" version\n// (called the \"target\" here).\nCS.VersionPricer.prototype.priceVersionsWithPrevious = function (\n  versions, target, takePatches) {\n\n  var self = this;\n  var parts = self.partitionVersions(versions, target);\n\n  var result1 = self.priceVersions(parts.older, CS.VersionPricer.MODE_UPDATE,\n                                   { versionAfter: target });\n  // Usually, it's better to remain as close as possible to the target\n  // version, but prefer higher patch versions (and wrapNums, etc.) if\n  // we were passed `takePatches`.\n  var result2 = self.priceVersions(parts.compatible,\n                                   (takePatches ?\n                                    CS.VersionPricer.MODE_GRAVITY_WITH_PATCHES :\n                                    CS.VersionPricer.MODE_GRAVITY));\n  // If we're already bumping the major version, might as well take patches.\n  var result3 = self.priceVersions(parts.higherMajor,\n                                   CS.VersionPricer.MODE_GRAVITY_WITH_PATCHES,\n                                   // not actually the version right before, but\n                                   // gives the `major` cost the bump it needs\n                                   { versionBefore: target });\n\n  // Generate a fifth array, incompat, which has a 1 for each incompatible\n  // version and a 0 for each compatible version.\n  var incompat = [];\n  var i;\n  for (i = 0; i < parts.older.length; i++) {\n    incompat.push(1);\n  }\n  for (i = 0; i < parts.compatible.length; i++) {\n    incompat.push(0);\n  }\n  for (i = 0; i < parts.higherMajor.length; i++) {\n    incompat.push(1);\n  }\n\n  return [\n    incompat,\n    result1[0].concat(result2[0], result3[0]),\n    result1[1].concat(result2[1], result3[1]),\n    result1[2].concat(result2[2], result3[2]),\n    result1[3].concat(result2[3], result3[3])\n  ];\n};\n","var CS = ConstraintSolver;\nvar PV = PackageVersion;\n\nvar pvVar = function (p, v) {\n  return p + ' ' + v;\n};\n\n// The \"inner solver\".  You construct it with a ConstraintSolver.Input object\n// (which specifies the problem) and then call .getAnswer() on it.\n\nCS.Solver = function (input, options) {\n  var self = this;\n  check(input, CS.Input);\n\n  self.input = input;\n  self.errors = []; // [String]\n\n  self.pricer = new CS.VersionPricer();\n  self.getConstraintFormula = _.memoize(_getConstraintFormula,\n                                         function (p, vConstraint) {\n                                           return p + \"@\" + vConstraint.raw;\n                                         });\n\n  self.options = options || {};\n  self.Profile = (self.options.Profile || CS.DummyProfile);\n\n  self.steps = [];\n  self.stepsByName = {};\n\n  self.analysis = {};\n\n  self.Profile.time(\"Solver#analyze\", function () {\n    self.analyze();\n  });\n\n  self.logic = null; // Logic.Solver, initialized later\n};\n\nCS.Solver.prototype.throwAnyErrors = function () {\n  if (this.errors.length) {\n    var multiline = _.any(this.errors, function (e) {\n      return /\\n/.test(e);\n    });\n    CS.throwConstraintSolverError(this.errors.join(\n      multiline ? '\\n\\n' : '\\n'));\n  }\n};\n\nCS.Solver.prototype.getVersions = function (package) {\n  var self = this;\n  if (_.has(self.analysis.allowedVersions, package)) {\n    return self.analysis.allowedVersions[package];\n  } else {\n    return self.input.catalogCache.getPackageVersions(package);\n  }\n};\n\n// Populates `self.analysis` with various data structures derived from the\n// input.  May also throw errors, and may call methods that rely on\n// analysis once that particular analysis is done (e.g. `self.getVersions`\n// which relies on `self.analysis.allowedVersions`.\nCS.Solver.prototype.analyze = function () {\n  var self = this;\n  var analysis = self.analysis;\n  var input = self.input;\n  var cache = input.catalogCache;\n  var Profile = self.Profile;\n\n  ////////// ANALYZE ALLOWED VERSIONS\n  // (An \"allowed version\" is one that isn't ruled out by a top-level\n  // constraint.)\n\n  // package -> array of version strings.  If a package has an entry in\n  // this map, then only the versions in the array are allowed for\n  // consideration.\n  analysis.allowedVersions = {};\n  analysis.packagesWithNoAllowedVersions = {}; // package -> [constraints]\n\n  // Process top-level constraints, applying them right now by\n  // limiting what package versions we even consider.  This speeds up\n  // solving, especially given the equality constraints on core\n  // packages.  For versions we don't allow, we get to avoid generating\n  // Constraint objects for their constraints, which saves us both\n  // clause generation time and solver work up through the point where we\n  // determine there are no conflicts between constraints.\n  //\n  // we can't throw any errors yet, because `input.constraints`\n  // doesn't establish any dependencies (so we don't know if it's a\n  // problem that some package has no legal versions), but we can\n  // track such packages in packagesWithNoAllowedVersions so that we\n  // throw a good error later.\n  Profile.time(\"analyze allowed versions\", function () {\n    _.each(_.groupBy(input.constraints, 'package'), function (cs, p) {\n      var versions = cache.getPackageVersions(p);\n      if (! versions.length) {\n        // deal with wholly unknown packages later\n        return;\n      }\n      _.each(cs, function (constr) {\n        versions = _.filter(versions, function (v) {\n          return CS.isConstraintSatisfied(p, constr.versionConstraint, v);\n        });\n      });\n      if (! versions.length) {\n        analysis.packagesWithNoAllowedVersions[p] = _.filter(cs, function (c) {\n          return !! c.constraintString;\n        });\n      }\n      analysis.allowedVersions[p] = versions;\n    });\n  });\n\n  ////////// ANALYZE ROOT DEPENDENCIES\n\n  // Collect root dependencies that we've never heard of.\n  analysis.unknownRootDeps = [];\n  // Collect \"previous solution\" versions of root dependencies.\n  analysis.previousRootDepVersions = [];\n\n  Profile.time(\"analyze root dependencies\", function () {\n    _.each(input.dependencies, function (p) {\n      if (! input.isKnownPackage(p)) {\n        analysis.unknownRootDeps.push(p);\n      } else if (input.isInPreviousSolution(p) &&\n                 ! input.isUpgrading(p)) {\n        analysis.previousRootDepVersions.push(new CS.PackageAndVersion(\n          p, input.previousSolution[p]));\n      }\n    });\n\n    // throw if there are unknown packages in root deps\n    if (analysis.unknownRootDeps.length) {\n      _.each(analysis.unknownRootDeps, function (p) {\n        self.errors.push('unknown package in top-level dependencies: ' + p);\n      });\n      self.throwAnyErrors();\n    }\n  });\n\n  ////////// ANALYZE REACHABILITY\n\n  // A \"reachable\" package is one that is either a root dependency or\n  // a strong dependency of any \"allowed\" version of a reachable package.\n  // In other words, we walk all strong dependencies starting\n  // with the root dependencies, and visiting all allowed versions of each\n  // package.\n  //\n  // This analysis is mainly done for performance, because if there are\n  // extraneous packages in the CatalogCache (for whatever reason) we\n  // want to spend as little time on them as possible.  It also establishes\n  // the universe of possible \"known\" and \"unknown\" packages we might\n  // come across.\n  //\n  // A more nuanced reachability analysis that takes versions into account\n  // is probably possible.\n\n  // package name -> true\n  analysis.reachablePackages = {};\n  // package name -> package versions asking for it (in pvVar form)\n  analysis.unknownPackages = {};\n\n  var markReachable = function (p) {\n    analysis.reachablePackages[p] = true;\n\n    _.each(self.getVersions(p), function (v) {\n      _.each(cache.getDependencyMap(p, v), function (dep) {\n        // `dep` is a CS.Dependency\n        var p2 = dep.packageConstraint.package;\n        if (! input.isKnownPackage(p2)) {\n          // record this package so we will generate a variable\n          // for it.  we'll try not to select it, and ultimately\n          // throw an error if we are forced to.\n          if (! _.has(analysis.unknownPackages, p2)) {\n            analysis.unknownPackages[p2] = [];\n          }\n          analysis.unknownPackages[p2].push(pvVar(p, v));\n        } else {\n          if (! dep.isWeak) {\n            if (! _.has(analysis.reachablePackages, p2)) {\n              markReachable(p2);\n            }\n          }\n        }\n      });\n    });\n  };\n\n  Profile.time(\"analyze reachability\", function () {\n    _.each(input.dependencies, markReachable);\n  });\n\n  ////////// ANALYZE CONSTRAINTS\n\n  // Array of CS.Solver.Constraint\n  analysis.constraints = [];\n  // packages `foo` such that there's a simple top-level equality\n  // constraint about `foo`.  package name -> true.\n  analysis.topLevelEqualityConstrainedPackages = {};\n\n  Profile.time(\"analyze constraints\", function () {\n    // top-level constraints\n    _.each(input.constraints, function (c) {\n      if (c.constraintString) {\n        analysis.constraints.push(new CS.Solver.Constraint(\n          null, c.package, c.versionConstraint,\n          \"constraint#\" + analysis.constraints.length));\n\n        if (c.versionConstraint.alternatives.length === 1 &&\n            c.versionConstraint.alternatives[0].type === 'exactly') {\n          analysis.topLevelEqualityConstrainedPackages[c.package] = true;\n        }\n      }\n    });\n\n    // constraints specified in package dependencies\n    _.each(_.keys(analysis.reachablePackages), function (p) {\n      _.each(self.getVersions(p), function (v) {\n        var pv = pvVar(p, v);\n        _.each(cache.getDependencyMap(p, v), function (dep) {\n          // `dep` is a CS.Dependency\n          var p2 = dep.packageConstraint.package;\n          if (input.isKnownPackage(p2) &&\n              dep.packageConstraint.constraintString) {\n            analysis.constraints.push(new CS.Solver.Constraint(\n              pv, p2, dep.packageConstraint.versionConstraint,\n              \"constraint#\" + analysis.constraints.length));\n          }\n        });\n      });\n    });\n  });\n\n  ////////// ANALYZE PRE-RELEASES\n\n  Profile.time(\"analyze pre-releases\", function () {\n    var unanticipatedPrereleases = [];\n    _.each(_.keys(analysis.reachablePackages), function (p) {\n      var anticipatedPrereleases = input.anticipatedPrereleases[p];\n      _.each(self.getVersions(p), function (v) {\n        if (/-/.test(v) && ! (anticipatedPrereleases &&\n                              _.has(anticipatedPrereleases, v))) {\n          unanticipatedPrereleases.push(pvVar(p, v));\n        }\n      });\n    });\n    analysis.unanticipatedPrereleases = unanticipatedPrereleases;\n  });\n};\n\n// A Step consists of a name, an array of terms, and an array of weights.\n// Steps are optimized one by one.  Optimizing a Step means to find\n// the minimum whole number value for the weighted sum of the terms,\n// and then to enforce in the solver that the weighted sum be that number.\n// Thus, when the Steps are optimized in sequence, earlier Steps take\n// precedence and will stay minimized while later Steps are optimized.\n//\n// A term can be a package name, a package version, or any other variable\n// name or Logic formula.\n//\n// A weight is a non-negative integer.  The weights array can be a single\n// weight (which is used for all terms).\n//\n// The terms and weights arguments each default to [].  You can add terms\n// with weights using addTerm.\n//\n// options is optional.\nCS.Solver.Step = function (name, terms, weights) {\n  check(name, String);\n  terms = terms || [];\n  check(terms, [String]);\n  weights = (weights == null ? [] : weights);\n  check(weights, Match.OneOf([Logic.WholeNumber], Logic.WholeNumber));\n\n  this.name = name;\n\n  // mutable:\n  this.terms = terms;\n  this.weights = weights;\n  this.optimum = null; // set when optimized\n};\n\n// If weights is a single number, you can omit the weight argument.\n// Adds a term.  If weight is 0, addTerm may skip it.\nCS.Solver.Step.prototype.addTerm = function (term, weight) {\n  if (weight == null) {\n    if (typeof this.weights !== 'number') {\n      throw new Error(\"Must specify a weight\");\n    }\n    weight = this.weights;\n  }\n  check(weight, Logic.WholeNumber);\n  if (weight !== 0) {\n    this.terms.push(term);\n    if (typeof this.weights === 'number') {\n      if (weight !== this.weights) {\n        throw new Error(\"Can't specify a different weight now: \" +\n                        weight + \" != \" + this.weights);\n      }\n    } else {\n      this.weights.push(weight);\n    }\n  }\n};\n\nvar DEBUG = false;\n\n// Call as one of:\n// * minimize(step, options)\n// * minimize([step1, step2, ...], options)\n// * minimize(stepName, costTerms, costWeights, options)\nCS.Solver.prototype.minimize = function (step, options) {\n  var self = this;\n\n  if (_.isArray(step)) {\n    // minimize([steps...], options)\n    _.each(step, function (st) {\n      self.minimize(st, options);\n    });\n    return;\n  }\n\n  if (typeof step === 'string') {\n    // minimize(stepName, costTerms, costWeights, options)\n    var stepName_ = arguments[0];\n    var costTerms_ = arguments[1];\n    var costWeights_ = arguments[2];\n    var options_ = arguments[3];\n    if (costWeights_ && typeof costWeights_ === 'object' &&\n        ! _.isArray(costWeights_)) {\n      options_ = costWeights_;\n      costWeights_ = null;\n    }\n    var theStep = new CS.Solver.Step(\n      stepName_, costTerms_, (costWeights_ == null ? 1 : costWeights_));\n    self.minimize(theStep, options_);\n    return;\n  }\n\n  // minimize(step, options);\n\n  self.Profile.time(\"minimize \" + step.name, function () {\n\n    var logic = self.logic;\n\n    self.steps.push(step);\n    self.stepsByName[step.name] = step;\n\n    if (DEBUG) {\n      console.log(\"--- MINIMIZING \" + step.name);\n    }\n\n    var costWeights = step.weights;\n    var costTerms = step.terms;\n\n    self.setSolution(logic.minimize(\n      self.solution, costTerms, costWeights, {\n        progress: function (status, cost) {\n          if (self.options.nudge) {\n            self.options.nudge();\n          }\n          if (DEBUG) {\n            if (status === 'improving') {\n              console.log(cost + \" ... trying to improve ...\");\n            }\n          }\n        },\n        strategy: (options && options.strategy)\n      }));\n\n    step.optimum = self.solution.getWeightedSum(costTerms, costWeights);\n    if (DEBUG) {\n      console.log(step.optimum + \" is optimal\");\n\n      if (step.optimum) {\n        _.each(costTerms, function (t, i) {\n          var w = (typeof costWeights === 'number' ? costWeights :\n                   costWeights[i]);\n          if (w && self.solution.evaluate(t)) {\n            console.log(\"    \" + w + \": \" + t);\n          }\n        });\n      }\n    }\n  });\n};\n\n// Determine the non-zero contributions to the cost function in `step`\n// based on the current solution, returning a map from term (usually\n// the name of a package or package version) to positive integer cost.\nCS.Solver.prototype.getStepContributions = function (step) {\n  var self = this;\n  var solution = self.solution;\n  var contributions = {};\n  var weights = step.weights;\n  _.each(step.terms, function (t, i) {\n    var w = (typeof weights === 'number' ? weights : weights[i]);\n    if (w && self.solution.evaluate(t)) {\n      contributions[t] = w;\n    }\n  });\n  return contributions;\n};\n\nvar addCostsToSteps = function (package, versions, costs, steps) {\n  var pvs = _.map(versions, function (v) {\n    return pvVar(package, v);\n  });\n  for (var j = 0; j < steps.length; j++) {\n    var step = steps[j];\n    var costList = costs[j];\n    if (costList.length !== versions.length) {\n      throw new Error(\"Assertion failure: Bad lengths in addCostsToSteps\");\n    }\n    for (var i = 0; i < versions.length; i++) {\n      step.addTerm(pvs[i], costList[i]);\n    }\n  }\n};\n\n// Get an array of \"Steps\" that, when minimized in order, optimizes\n// the package version costs of `packages` (an array of String package\n// names) according to `pricerMode`, which may be\n// `CS.VersionPricer.MODE_UPDATE` or a similar mode constant.\n// Wraps `VersionPricer#priceVersions`, which is tasked with calculating\n// the cost of every version of every package.  This function iterates\n// over `packages` and puts the result into `Step` objects.\nCS.Solver.prototype.getVersionCostSteps = function (stepBaseName, packages,\n                                                    pricerMode) {\n  var self = this;\n  var major = new CS.Solver.Step(stepBaseName + '_major');\n  var minor = new CS.Solver.Step(stepBaseName + '_minor');\n  var patch = new CS.Solver.Step(stepBaseName + '_patch');\n  var rest = new CS.Solver.Step(stepBaseName + '_rest');\n\n  self.Profile.time(\n    \"calculate \" + stepBaseName + \" version costs\",\n    function () {\n      _.each(packages, function (p) {\n        var versions = self.getVersions(p);\n        var costs = self.pricer.priceVersions(versions, pricerMode);\n        addCostsToSteps(p, versions, costs, [major, minor, patch, rest]);\n      });\n    });\n\n  return [major, minor, patch, rest];\n};\n\n// Like `getVersionCostSteps`, but wraps\n// `VersionPricer#priceVersionsWithPrevious` instead of `#priceVersions`.\n// The cost function is \"distance\" from the previous versions passed in\n// as `packageAndVersion`.  (Actually it's a complicated function of the\n// previous and new version.)\nCS.Solver.prototype.getVersionDistanceSteps = function (stepBaseName,\n                                                        packageAndVersions,\n                                                        takePatches) {\n  var self = this;\n\n  var incompat = new CS.Solver.Step(stepBaseName + '_incompat');\n  var major = new CS.Solver.Step(stepBaseName + '_major');\n  var minor = new CS.Solver.Step(stepBaseName + '_minor');\n  var patch = new CS.Solver.Step(stepBaseName + '_patch');\n  var rest = new CS.Solver.Step(stepBaseName + '_rest');\n\n  self.Profile.time(\n    \"calculate \" + stepBaseName + \" distance costs\",\n    function () {\n      _.each(packageAndVersions, function (pvArg) {\n        var package = pvArg.package;\n        var previousVersion = pvArg.version;\n        var versions = self.getVersions(package);\n        var costs = self.pricer.priceVersionsWithPrevious(\n          versions, previousVersion, takePatches);\n        addCostsToSteps(package, versions, costs,\n                        [incompat, major, minor, patch, rest]);\n      });\n    });\n\n  return [incompat, major, minor, patch, rest];\n};\n\nCS.Solver.prototype.currentVersionMap = function () {\n  var self = this;\n  var pvs = [];\n  _.each(self.solution.getTrueVars(), function (x) {\n    if (x.indexOf(' ') >= 0) {\n      // all variables with spaces in them are PackageAndVersions\n      var pv = CS.PackageAndVersion.fromString(x);\n      pvs.push(pv);\n    }\n  });\n\n  var versionMap = {};\n  _.each(pvs, function (pv) {\n    if (_.has(versionMap, pv.package)) {\n      throw new Error(\"Assertion failure: Selected two versions of \" +\n                      pv.package + \", \" +versionMap[pv.package] +\n                      \" and \" + pv.version);\n    }\n    versionMap[pv.package] = pv.version;\n  });\n\n  return versionMap;\n};\n\n// Called to re-assign `self.solution` after a call to `self.logic.solve()`,\n// `solveAssuming`, or `minimize`.\nCS.Solver.prototype.setSolution = function (solution) {\n  var self = this;\n  self.solution = solution;\n  if (! self.solution) {\n    throw new Error(\"Unexpected unsatisfiability\");\n  }\n  self.solution.ignoreUnknownVariables = true;\n};\n\nCS.Solver.prototype.getAnswer = function (options) {\n  var self = this;\n  return self.Profile.time(\"Solver#getAnswer\", function () {\n    return self._getAnswer(options);\n  });\n};\n\nCS.Solver.prototype._getAnswer = function (options) {\n  var self = this;\n  var input = self.input;\n  var analysis = self.analysis;\n  var cache = input.catalogCache;\n  var allAnswers = (options && options.allAnswers); // for tests\n  var Profile = self.Profile;\n\n  var logic;\n  Profile.time(\"new Logic.Solver (MiniSat start-up)\", function () {\n    logic = self.logic = new Logic.Solver();\n  });\n\n  // require root dependencies\n  Profile.time(\"require root dependencies\", function () {\n    _.each(input.dependencies, function (p) {\n      logic.require(p);\n    });\n  });\n\n  // generate package version variables for known, reachable packages\n  Profile.time(\"generate package variables\", function () {\n    _.each(_.keys(analysis.reachablePackages), function (p) {\n      if (! _.has(analysis.packagesWithNoAllowedVersions, p)) {\n        var versionVars = _.map(self.getVersions(p),\n                                function (v) {\n                                  return pvVar(p, v);\n                                });\n        // At most one of [\"foo 1.0.0\", \"foo 1.0.1\", ...] is true.\n        logic.require(Logic.atMostOne(versionVars));\n        // The variable \"foo\" is true if and only if at least one of the\n        // variables [\"foo 1.0.0\", \"foo 1.0.1\", ...] is true.\n        logic.require(Logic.equiv(p, Logic.or(versionVars)));\n      }\n    });\n  });\n\n  // generate strong dependency requirements\n  Profile.time(\"generate dependency requirements\", function () {\n    _.each(_.keys(analysis.reachablePackages), function (p) {\n      _.each(self.getVersions(p), function (v) {\n        _.each(cache.getDependencyMap(p, v), function (dep) {\n          // `dep` is a CS.Dependency\n          if (! dep.isWeak) {\n            var p2 = dep.packageConstraint.package;\n            logic.require(Logic.implies(pvVar(p, v), p2));\n          }\n        });\n      });\n    });\n  });\n\n  // generate constraints -- but technically don't enforce them, because\n  // we haven't forced the conflictVars to be false\n  Profile.time(\"generate constraints\", function () {\n    _.each(analysis.constraints, function (c) {\n      // We logically require that EITHER a constraint is marked as a\n      // conflict OR it comes from a package version that is not selected\n      // OR its constraint formula must be true.\n      // (The constraint formula says that if toPackage is selected,\n      // then a version of it that satisfies our constraint must be true.)\n      logic.require(\n        Logic.or(c.conflictVar,\n                 c.fromVar ? Logic.not(c.fromVar) : [],\n                 self.getConstraintFormula(c.toPackage, c.vConstraint)));\n    });\n  });\n\n  // Establish the invariant of self.solution being a valid solution.\n  // From now on, if we add some new logical requirement to the solver\n  // that isn't necessarily true of `self.solution`, we must\n  // recalculate `self.solution` and pass the new value to\n  // self.setSolution.  It is our job to obtain the new solution in a\n  // way that ensures the solution exists and doesn't put the solver\n  // in an unsatisfiable state.  There are several ways to do this:\n  //\n  // * Calling `logic.solve()` and immediately throwing a fatal error\n  //   if there's no solution (not calling `setSolution` at all)\n  // * Calling `logic.solve()` in a situation where we know we have\n  //   not made the problem unsatisfiable\n  // * Calling `logic.solveAssuming(...)` and checking the result, only\n  //   using the solution if it exists\n  // * Calling `minimize()`, which always maintains satisfiability\n\n  Profile.time(\"pre-solve\", function () {\n    self.setSolution(logic.solve());\n  });\n  // There is always a solution at this point, namely,\n  // select all packages (including unknown packages), select\n  // any version of each known package (excluding packages with\n  // \"no allowed versions\"), and set all conflictVars\n  // to true.\n\n  // Forbid packages with no versions allowed by top-level constraints,\n  // which we didn't do earlier because we needed to establish an\n  // initial solution before asking the solver if it's possible to\n  // not use these packages.\n  Profile.time(\"forbid packages with no matching versions\", function () {\n    _.each(analysis.packagesWithNoAllowedVersions, function (constrs, p) {\n      var newSolution = logic.solveAssuming(Logic.not(p));\n      if (newSolution) {\n        self.setSolution(newSolution);\n        logic.forbid(p);\n      } else {\n        self.errors.push(\n          'No version of ' + p + ' satisfies all constraints: ' +\n            _.map(constrs, function (constr) {\n              return '@' + constr.constraintString;\n            }).join(', '));\n      }\n    });\n    self.throwAnyErrors();\n  });\n\n  // try not to use any unknown packages.  If the minimum is greater\n  // than 0, we'll throw an error later, after we apply the constraints\n  // and the cost function, so that we can explain the problem to the\n  // user in a convincing way.\n  self.minimize('unknown_packages', _.keys(analysis.unknownPackages));\n\n  // try not to set the conflictVar on any constraint.  If the minimum\n  // is greater than 0, we'll throw an error later, after we've run the\n  // cost function, so we can show a better error.\n  // If there are conflicts, this minimization can be time-consuming\n  // (several seconds or more).  The strategy 'bottom-up' helps by\n  // looking for solutions with few conflicts first.\n  self.minimize('conflicts', _.pluck(analysis.constraints, 'conflictVar'),\n                { strategy: 'bottom-up' });\n\n  // Try not to use \"unanticipated\" prerelease versions\n  self.minimize('unanticipated_prereleases',\n                analysis.unanticipatedPrereleases);\n\n  var previousRootSteps = self.getVersionDistanceSteps(\n    'previous_root', analysis.previousRootDepVersions);\n  // the \"previous_root_incompat\" step\n  var previousRootIncompat = previousRootSteps[0];\n  // the \"previous_root_major\", \"previous_root_minor\", etc. steps\n  var previousRootVersionParts = previousRootSteps.slice(1);\n\n  var toUpdate = _.filter(input.upgrade, function (p) {\n    return analysis.reachablePackages[p] === true;\n  });\n\n  if (! input.allowIncompatibleUpdate) {\n    // make sure packages that are being updated can still count as\n    // a previous_root for the purposes of previous_root_incompat\n    Profile.time(\"add terms to previous_root_incompat\", function () {\n      _.each(toUpdate, function (p) {\n        if (input.isRootDependency(p) && input.isInPreviousSolution(p)) {\n          var parts = self.pricer.partitionVersions(\n            self.getVersions(p), input.previousSolution[p]);\n          _.each(parts.older.concat(parts.higherMajor), function (v) {\n            previousRootIncompat.addTerm(pvVar(p, v), 1);\n          });\n        }\n      });\n    });\n\n    // Enforce that we don't make breaking changes to your root dependencies,\n    // unless you pass --allow-incompatible-update.  It will actually be enforced\n    // farther down, but for now, we want to apply this constraint before handling\n    // updates.\n    self.minimize(previousRootIncompat);\n  }\n\n  self.minimize(self.getVersionCostSteps(\n    'update', toUpdate, CS.VersionPricer.MODE_UPDATE));\n\n  if (input.allowIncompatibleUpdate) {\n    // If you pass `--allow-incompatible-update`, we will still try to minimize\n    // version changes to root deps that break compatibility, but with a lower\n    // priority than taking as-new-as-possible versions for `meteor update`.\n    self.minimize(previousRootIncompat);\n  }\n\n  self.minimize(previousRootVersionParts);\n\n  var otherPrevious = _.filter(_.map(input.previousSolution, function (v, p) {\n    return new CS.PackageAndVersion(p, v);\n  }), function (pv) {\n    var p = pv.package;\n    return analysis.reachablePackages[p] === true &&\n      ! input.isRootDependency(p);\n  });\n\n  self.minimize(self.getVersionDistanceSteps(\n    'previous_indirect', otherPrevious,\n    input.upgradeIndirectDepPatchVersions));\n\n  var newRootDeps = _.filter(input.dependencies, function (p) {\n    return ! input.isInPreviousSolution(p);\n  });\n\n  self.minimize(self.getVersionCostSteps(\n    'new_root', newRootDeps, CS.VersionPricer.MODE_UPDATE));\n\n  // Lock down versions of all root, previous, and updating packages that\n  // are currently selected.  The reason to do this is to save the solver\n  // a bunch of work (i.e. improve performance) by not asking it to\n  // optimize the \"unimportant\" packages while also twiddling the versions\n  // of the \"important\" packages, which would just multiply the search space.\n  //\n  // The important packages are root deps, packages in the previous solution,\n  // and packages being upgraded.  At this point, we either have unique\n  // versions for them, or else there is some kind of trade-off, like a\n  // situation where raising the version of one package and lowering the\n  // version of another produces the same cost -- a tie between two solutions.\n  // If we have a tie, it probably won't be broken by the unimportant\n  // packages, so we'll end up going with whatever we picked anyway.  (Note\n  // that we have already taken the unimportant packages into account in that\n  // we are only considering solutions where SOME versions can be chosen for\n  // them.)  Even if optimizing the unimportant packages (coming up next)\n  // was able to break a tie in the important packages, we care so little\n  // about the versions of the unimportant packages that it's a very weak\n  // signal.  In other words, the user might be better off with some tie-breaker\n  // that looks only at the important packages anyway.\n  Profile.time(\"lock down important versions\", function () {\n    _.each(self.currentVersionMap(), function (v, package) {\n      if (input.isRootDependency(package) ||\n          input.isInPreviousSolution(package) ||\n          input.isUpgrading(package)) {\n        logic.require(Logic.implies(package, pvVar(package, v)));\n      }\n    });\n  });\n\n  // new, indirect packages are the lowest priority\n  var otherPackages = [];\n  _.each(_.keys(analysis.reachablePackages), function (p) {\n    if (! (input.isRootDependency(p) ||\n           input.isInPreviousSolution(p) ||\n           input.isUpgrading(p))) {\n      otherPackages.push(p);\n    }\n  });\n\n  self.minimize(self.getVersionCostSteps(\n    'new_indirect', otherPackages,\n    CS.VersionPricer.MODE_GRAVITY_WITH_PATCHES));\n\n  self.minimize('total_packages', _.keys(analysis.reachablePackages));\n\n  // throw errors about unknown packages\n  if (self.stepsByName['unknown_packages'].optimum > 0) {\n    Profile.time(\"generate error for unknown packages\", function () {\n      var unknownPackages = _.keys(analysis.unknownPackages);\n      var unknownPackagesNeeded = _.filter(unknownPackages, function (p) {\n        return self.solution.evaluate(p);\n      });\n      _.each(unknownPackagesNeeded, function (p) {\n        var requirers = _.filter(analysis.unknownPackages[p], function (pv) {\n          return self.solution.evaluate(pv);\n        });\n        var errorStr = 'unknown package: ' + p;\n        _.each(requirers, function (pv) {\n          errorStr += '\\nRequired by: ' + pv;\n        });\n        self.errors.push(errorStr);\n      });\n    });\n    self.throwAnyErrors();\n  }\n\n  // throw errors about conflicts\n  if (self.stepsByName['conflicts'].optimum > 0) {\n    self.throwConflicts();\n  }\n\n  if ((! input.allowIncompatibleUpdate) &&\n      self.stepsByName['previous_root_incompat'].optimum > 0) {\n    // we have some \"incompatible root changes\", where we needed to change a\n    // version of a root dependency to a new version incompatible with the\n    // original, but --allow-incompatible-update hasn't been passed in.\n    // these are in the form of PackageAndVersion strings that we need.\n    var incompatRootChanges = _.keys(self.getStepContributions(\n      self.stepsByName['previous_root_incompat']));\n\n    Profile.time(\"generate errors for incompatible root change\", function () {\n      var numActualErrors = 0;\n      _.each(incompatRootChanges, function (pvStr) {\n        var pv = CS.PackageAndVersion.fromString(pvStr);\n        // exclude packages with top-level equality constraints (added by user\n        // or by the tool pinning a version)\n        if (! _.has(analysis.topLevelEqualityConstrainedPackages, pv.package)) {\n          var prevVersion = input.previousSolution[pv.package];\n          self.errors.push(\n            'Potentially incompatible change required to ' +\n              'top-level dependency: ' +\n              pvStr + ', was ' + prevVersion + '.\\n' +\n              self.listConstraintsOnPackage(pv.package));\n          numActualErrors++;\n        }\n      });\n      if (numActualErrors) {\n        self.errors.push(\n          'To allow potentially incompatible changes to top-level ' +\n            'dependencies, you must pass --allow-incompatible-update ' +\n            'on the command line.');\n      }\n    });\n    self.throwAnyErrors();\n  }\n\n  var result = {\n    neededToUseUnanticipatedPrereleases: (\n      self.stepsByName['unanticipated_prereleases'].optimum > 0),\n    answer: Profile.time(\"generate version map\", function () {\n      return self.currentVersionMap();\n    })\n  };\n\n  if (allAnswers) {\n    Profile.time(\"generate all answers\", function () {\n      var allAnswersList = [result.answer];\n      var nextAnswer = function () {\n        var formula = self.solution.getFormula();\n        var newSolution = logic.solveAssuming(Logic.not(formula));\n        if (newSolution) {\n          self.setSolution(newSolution);\n          logic.forbid(formula);\n        }\n        return newSolution;\n      };\n      while (nextAnswer()) {\n        allAnswersList.push(self.currentVersionMap());\n      }\n      result.allAnswers = allAnswersList;\n    });\n  };\n\n  return result;\n};\n\n// Get a list of package-version variables that satisfy a given constraint.\nvar getOkVersions = function (toPackage, vConstraint, targetVersions) {\n  return _.compact(_.map(targetVersions, function (v) {\n    if (CS.isConstraintSatisfied(toPackage, vConstraint, v)) {\n      return pvVar(toPackage, v);\n    } else {\n      return null;\n    }\n  }));\n};\n\n// The CS.Solver constructor turns this into a memoized method.\n// Memoizing the Formula object reduces clause generation a lot.\nvar _getConstraintFormula = function (toPackage, vConstraint) {\n  var self = this;\n\n  var targetVersions = self.getVersions(toPackage);\n  var okVersions = getOkVersions(toPackage, vConstraint, targetVersions);\n\n  if (okVersions.length === targetVersions.length) {\n    return Logic.TRUE;\n  } else {\n    return Logic.or(Logic.not(toPackage), okVersions);\n  }\n};\n\nCS.Solver.prototype.listConstraintsOnPackage = function (package) {\n  var self = this;\n  var constraints = self.analysis.constraints;\n\n  var result = 'Constraints on package \"' + package + '\":';\n\n  _.each(constraints, function (c) {\n    if (c.toPackage === package) {\n      var paths;\n      if (c.fromVar) {\n        paths = self.getPathsToPackageVersion(\n          CS.PackageAndVersion.fromString(c.fromVar));\n      } else {\n        paths = [['top level']];\n      }\n      _.each(paths, function (path) {\n        result += '\\n* ' + (new PV.PackageConstraint(\n          package, c.vConstraint.raw)) + ' <- ' + path.join(' <- ');\n      });\n    }\n  });\n\n  return result;\n};\n\nCS.Solver.prototype.throwConflicts = function () {\n  var self = this;\n\n  var solution = self.solution;\n  var constraints = self.analysis.constraints;\n\n  self.Profile.time(\"generate error about conflicts\", function () {\n    _.each(constraints, function (c) {\n      // c is a CS.Solver.Constraint\n      if (solution.evaluate(c.conflictVar)) {\n        // skipped this constraint\n        var possibleVersions = self.getVersions(c.toPackage);\n        var chosenVersion = _.find(possibleVersions, function (v) {\n          return solution.evaluate(pvVar(c.toPackage, v));\n        });\n        if (! chosenVersion) {\n          // this can't happen, because for a constraint to be a problem,\n          // we must have chosen some version of the package it applies to!\n          throw new Error(\"Internal error: Version not found\");\n        }\n        var error = (\n          'Conflict: Constraint ' + (new PV.PackageConstraint(\n            c.toPackage, c.vConstraint)) +\n            ' is not satisfied by ' + c.toPackage + ' ' + chosenVersion + '.');\n\n        error += '\\n' + self.listConstraintsOnPackage(c.toPackage);\n\n        self.errors.push(error);\n      }\n    });\n  });\n\n  // always throws, never returns\n  self.throwAnyErrors();\n\n  throw new Error(\"Internal error: conflicts could not be explained\");\n};\n\n// Takes a PackageVersion and returns an array of arrays of PackageVersions.\n// If the `packageVersion` is not selected in `self.solution`, returns\n// an empty array.  Otherwise, returns an array of all paths from\n// root dependencies to the package, in reverse order.  In other words,\n// the first element of each path is `packageVersion`,\n// and the last element is the selected version of a root dependency.\n//\n// Ok, it isn't all paths.  Because that would be crazy (combinatorial\n// explosion).  It stops at root dependencies and tries to filter out\n// ones that are definitely longer than another.\nCS.Solver.prototype.getPathsToPackageVersion = function (packageAndVersion) {\n  check(packageAndVersion, CS.PackageAndVersion);\n  var self = this;\n  var input = self.input;\n  var cache = input.catalogCache;\n  var solution = self.solution;\n\n  var versionMap = self.currentVersionMap();\n  var hasDep = function (p1, p2) {\n    // Include weak dependencies, because their constraints matter.\n    return _.has(cache.getDependencyMap(p1, versionMap[p1]), p2);\n  };\n  var allPackages = _.keys(versionMap);\n\n  var getPaths = function (pv, _ignorePackageSet) {\n    if (! solution.evaluate(pv.toString())) {\n      return [];\n    }\n    var package = pv.package;\n\n    if (input.isRootDependency(package)) {\n      return [[pv]];\n    }\n\n    var newIgnorePackageSet = _.clone(_ignorePackageSet);\n    newIgnorePackageSet[package] = true;\n\n    var paths = [];\n    var shortestLength = null;\n\n    _.each(allPackages, function (p) {\n      if ((! _.has(newIgnorePackageSet, p)) &&\n          solution.evaluate(p) &&\n          hasDep(p, package)) {\n        var newPV = new CS.PackageAndVersion(p, versionMap[p]);\n        _.each(getPaths(newPV, newIgnorePackageSet), function (path) {\n          var newPath = [pv].concat(path);\n          if ((! paths.length) || newPath.length < shortestLength) {\n            paths.push(newPath);\n            shortestLength = newPath.length;\n          }\n        });\n      }\n    });\n\n    return paths;\n  };\n\n  return getPaths(packageAndVersion, {});\n};\n\n\nCS.Solver.Constraint = function (fromVar, toPackage, vConstraint, conflictVar) {\n  this.fromVar = fromVar;\n  this.toPackage = toPackage;\n  this.vConstraint = vConstraint;\n  this.conflictVar = conflictVar;\n\n  // this.fromVar is a return value of pvVar(p, v), or null for a\n  // top-level constraint\n  check(this.fromVar, Match.OneOf(String, null));\n  check(this.toPackage, String); // package name\n  check(this.vConstraint, PV.VersionConstraint);\n  check(this.conflictVar, String);\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// This is the entry point for the constraint-solver package.  The tool\n// creates a ConstraintSolver.PackagesResolver and calls .resolve on it.\n\nCS.PackagesResolver = function (catalog, options) {\n  var self = this;\n\n  self.catalog = catalog;\n  self.catalogCache = new CS.CatalogCache();\n  self.catalogLoader = new CS.CatalogLoader(self.catalog, self.catalogCache);\n\n  self._options = {\n    nudge: options && options.nudge,\n    Profile: options && options.Profile\n  };\n};\n\n// dependencies - an array of string names of packages (not slices)\n// constraints - an array of PV.PackageConstraints\n// options:\n//  - upgrade - list of dependencies for which upgrade is prioritized higher\n//    than keeping the old version\n//  - previousSolution - mapping from package name to a version that was used in\n//    the previous constraint solver run\n//  - anticipatedPrereleases: mapping from package name to version to true;\n//    included versions are the only pre-releases that are allowed to match\n//    constraints that don't specifically name them during the \"try not to\n//    use unanticipated pre-releases\" pass\n//  - allowIncompatibleUpdate: allows choosing versions of\n//    root dependencies that are incompatible with the previous solution,\n//    if necessary to satisfy all constraints\n//  - upgradeIndirectDepPatchVersions: also upgrade indirect dependencies\n//    to newer patch versions, proactively\n//  - missingPreviousVersionIsError - throw an error if a package version in\n//    previousSolution is not found in the catalog\nCS.PackagesResolver.prototype.resolve = function (dependencies, constraints,\n                                                  options) {\n  var self = this;\n  options = options || {};\n  var Profile = (self._options.Profile || CS.DummyProfile);\n\n  var input;\n  Profile.time(\"new CS.Input\", function () {\n    input = new CS.Input(dependencies, constraints, self.catalogCache,\n                         _.pick(options,\n                                'upgrade',\n                                'anticipatedPrereleases',\n                                'previousSolution',\n                                'allowIncompatibleUpdate',\n                                'upgradeIndirectDepPatchVersions'));\n  });\n\n  Profile.time(\n    \"Input#loadFromCatalog (sqlite)\",\n    function () {\n      input.loadFromCatalog(self.catalogLoader);\n    });\n\n  if (options.previousSolution && options.missingPreviousVersionIsError) {\n    Profile.time(\"check for previous versions in catalog\", function () {\n      _.each(options.previousSolution, function (version, package) {\n        if (! input.catalogCache.hasPackageVersion(package, version)) {\n          CS.throwConstraintSolverError(\n            \"Package version not in catalog: \" + package + \" \" + version);\n        }\n      });\n    });\n  }\n\n  return CS.PackagesResolver._resolveWithInput(input, {\n    nudge: self._options.nudge,\n    Profile: self._options.Profile\n  });\n};\n\n// Exposed for tests.\n//\n// Options (all optional):\n// - nudge (function to be called when possible to \"nudge\" the progress spinner)\n// - allAnswers (for testing, calculate all possible answers and put an extra\n//   property named \"allAnswers\" on the result)\n// - Profile (the profiler interface in `tools/profile.js`)\nCS.PackagesResolver._resolveWithInput = function (input, options) {\n  options = options || {};\n\n  if (Meteor.isServer &&\n      process.env['METEOR_PRINT_CONSTRAINT_SOLVER_INPUT']) {\n    console.log(\"CONSTRAINT_SOLVER_INPUT = \");\n    console.log(JSON.stringify(input.toJSONable(), null, 2));\n  }\n\n  var solver;\n  (options.Profile || CS.DummyProfile).time(\"new CS.Solver\", function () {\n    solver = new CS.Solver(input, {\n      nudge: options.nudge,\n      Profile: options.Profile\n    });\n  });\n\n  // Disable runtime type checks (they slow things down by a factor of 3)\n  return Logic._disablingTypeChecks(function () {\n    var result = solver.getAnswer({\n      allAnswers: options.allAnswers\n    });\n    // if we're here, no conflicts were found (or an error would have\n    // been thrown)\n    return result;\n  });\n};\n\n\n// - package: String package name\n// - vConstraint: a PackageVersion.VersionConstraint, or an object\n//   with an `alternatives` property lifted from one.\n// - version: version String\nCS.isConstraintSatisfied = function (package, vConstraint, version) {\n  return _.some(vConstraint.alternatives, function (simpleConstraint) {\n    var type = simpleConstraint.type;\n\n    if (type === \"any-reasonable\") {\n      return true;\n    } else if (type === \"exactly\") {\n      var cVersion = simpleConstraint.versionString;\n      return (cVersion === version);\n    } else if (type === 'compatible-with') {\n      var cv = PV.parse(simpleConstraint.versionString);\n      var v = PV.parse(version);\n\n      // If the candidate version is less than the version named in the\n      // constraint, we are not satisfied.\n      if (PV.lessThan(v, cv)) {\n        return false;\n      }\n\n      // To be compatible, the two versions must have the same major version\n      // number.\n      if (v.major !== cv.major) {\n        return false;\n      }\n\n      return true;\n    } else {\n      throw Error(\"Unknown constraint type: \" + type);\n    }\n  });\n};\n\nCS.throwConstraintSolverError = function (message) {\n  var e = new Error(message);\n  e.constraintSolverError = true;\n  throw e;\n};\n\n// Implements the Profile interface (as we use it) but doesn't do\n// anything.\nCS.DummyProfile = function (bucket, f) {\n  return f;\n};\nCS.DummyProfile.time = function (bucket, f) {\n  return f();\n};\n"]}