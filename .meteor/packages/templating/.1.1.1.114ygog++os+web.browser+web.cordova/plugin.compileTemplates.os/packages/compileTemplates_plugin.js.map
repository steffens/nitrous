{"version":3,"sources":["compileTemplates/plugin/html_scanner.js","compileTemplates/plugin/compile-templates.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,gB;AACA,4D;AACA,qC;AACA,I;AACA,wD;AACA,0D;AACA,yC;;AAEA,yC;AACA,2B;AACA,I;;AAEA,sB;;AAEA,0C;AACA,wB;AACA,kB;;AAEA,oC;AACA,oC;AACA,sB;AACA,M;;AAEA,yD;AACA,4C;AACA,6D;AACA,6B;AACA,iF;AACA,oE;AACA,gB;AACA,M;;AAEA,8C;AACA,4E;;AAEA,kB;AACA,wD;AACA,4C;;AAEA,sC;AACA,kB;AACA,sD;;AAEA,gC;AACA,wC;AACA,uC;AACA,2C;;AAEA,gC;AACA,6C;;AAEA,uB;AACA,yC;AACA,yC;AACA,iC;AACA,6C;AACA,yB;AACA,mD;AACA,yD;AACA,iB;AACA,O;AACA,kC;AACA,sD;AACA,yB;AACA,0B;AACA,8E;AACA,mB;AACA,0B;AACA,uE;AACA,S;AACA,0B;AACA,O;;AAEA,2B;AACA,oD;AACA,qD;AACA,yE;AACA,e;AACA,wB;AACA,4C;AACA,gC;AACA,8B;AACA,gC;AACA,6C;AACA,8B;AACA,gB;AACA,yD;AACA,6D;AACA,0D;AACA,qC;AACA,qE;AACA,wC;AACA,O;AACA,sC;AACA,8C;AACA,oB;AACA,mE;AACA,gB;AACA,kD;AACA,iD;AACA,qC;;AAEA,uB;AACA,wE;AACA,kE;AACA,6C;;AAEA,uE;AACA,yC;AACA,K;;AAEA,mB;AACA,I;;AAEA,4B;AACA,qB;AACA,sB;AACA,sB;AACA,oB;AACA,mB;AACA,I;;AAEA,yE;AACA,4D;;AAEA,6B;AACA,mE;AACA,iE;AACA,sC;AACA,oB;;AAEA,oC;AACA,2B;AACA,2B;AACA,sC;AACA,0B;AACA,c;AACA,O;AACA,K;;AAEA,yB;AACA,qB;AACA,8D;AACA,+B;AACA,a;AACA,K;;;AAGA,2B;;AAEA,S;AACA,+B;AACA,gC;AACA,mB;AACA,8D;;AAEA,mD;AACA,sE;;AAEA,uD;AACA,qB;AACA,6B;AACA,iD;AACA,a;;AAEA,+C;AACA,wE;;AAEA,wE;AACA,2D;AACA,kE;AACA,c;AACA,iB;AACA,yB;AACA,0E;AACA,gF;AACA,yB;AACA,+G;AACA,S;;AAEA,uD;AACA,qB;AACA,yB;AACA,gC;AACA,a;;AAEA,+C;AACA,+H;AACA,O;AACA,iB;AACA,sB;AACA,wC;AACA,kE;AACA,c;AACA,gB;AACA,O;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACtMA,+B;;AAEA,0D;AACA,oE;AACA,qB;AACA,qD;AACA,O;AACA,oE;AACA,e;AACA,8C;AACA,yB;AACA,2B;AACA,0C;AACA,oB;AACA,S;AACA,a;AACA,U;AACA,c;AACA,G;;AAEA,mB;AACA,wE;;AAEA,mB;AACA,wE;;AAEA,mB;AACA,wD;AACA,0B;AACA,qB;AACA,mD;AACA,uC;AACA,kD;AACA,6D;;AAEA,gC;;AAEA,+B;AACA,iE;AACA,wC;AACA,sB;AACA,O;AACA,G;AACA,E;;AAEA,6B;AACA,kD;AACA,0B;AACA,8C;AACA,G;AACA,E","file":"/packages/compileTemplates_plugin.js","sourcesContent":["html_scanner = {\n  // Scan a template file for <head>, <body>, and <template>\n  // tags and extract their contents.\n  //\n  // This is a primitive, regex-based scanner.  It scans\n  // top-level tags, which are allowed to have attributes,\n  // and ignores top-level HTML comments.\n\n  // Has fields 'message', 'line', 'file'\n  ParseError: function () {\n  },\n\n  bodyAttributes : [],\n\n  scan: function (contents, source_name) {\n    var rest = contents;\n    var index = 0;\n\n    var advance = function(amount) {\n      rest = rest.substring(amount);\n      index += amount;\n    };\n\n    var throwParseError = function (msg, overrideIndex) {\n      var ret = new html_scanner.ParseError;\n      ret.message = msg || \"bad formatting in HTML template\";\n      ret.file = source_name;\n      var theIndex = (typeof overrideIndex === 'number' ? overrideIndex : index);\n      ret.line = contents.substring(0, theIndex).split('\\n').length;\n      throw ret;\n    };\n\n    var results = html_scanner._initResults();\n    var rOpenTag = /^((<(template|head|body)\\b)|(<!--)|(<!DOCTYPE|{{!)|$)/i;\n\n    while (rest) {\n      // skip whitespace first (for better line numbers)\n      advance(rest.match(/^\\s*/)[0].length);\n\n      var match = rOpenTag.exec(rest);\n      if (! match)\n        throwParseError(); // unknown text encountered\n\n      var matchToken = match[1];\n      var matchTokenTagName =  match[3];\n      var matchTokenComment = match[4];\n      var matchTokenUnsupported = match[5];\n\n      var tagStartIndex = index;\n      advance(match.index + match[0].length);\n\n      if (! matchToken)\n        break; // matched $ (end of file)\n      if (matchTokenComment === '<!--') {\n        // top-level HTML comment\n        var commentEnd = /--\\s*>/.exec(rest);\n        if (! commentEnd)\n          throwParseError(\"unclosed HTML comment\");\n        advance(commentEnd.index + commentEnd[0].length);\n        continue;\n      }\n      if (matchTokenUnsupported) {\n        switch (matchTokenUnsupported.toLowerCase()) {\n        case '<!doctype':\n          throwParseError(\n            \"Can't set DOCTYPE here.  (Meteor sets <!DOCTYPE html> for you)\");\n        case '{{!':\n          throwParseError(\n            \"Can't use '{{! }}' outside a template.  Use '<!-- -->'.\");\n        }\n        throwParseError();\n      }\n\n      // otherwise, a <tag>\n      var tagName = matchTokenTagName.toLowerCase();\n      var tagAttribs = {}; // bare name -> value dict\n      var rTagPart = /^\\s*((([a-zA-Z0-9:_-]+)\\s*=\\s*([\"'])(.*?)\\4)|(>))/;\n      var attr;\n      // read attributes\n      while ((attr = rTagPart.exec(rest))) {\n        var attrToken = attr[1];\n        var attrKey = attr[3];\n        var attrValue = attr[5];\n        advance(attr.index + attr[0].length);\n        if (attrToken === '>')\n          break;\n        // XXX we don't HTML unescape the attribute value\n        // (e.g. to allow \"abcd&quot;efg\") or protect against\n        // collisions with methods of tagAttribs (e.g. for\n        // a property named toString)\n        attrValue = attrValue.match(/^\\s*([\\s\\S]*?)\\s*$/)[1]; // trim\n        tagAttribs[attrKey] = attrValue;\n      }\n      if (! attr) // didn't end on '>'\n        throwParseError(\"Parse error in tag\");\n      // find </tag>\n      var end = (new RegExp('</'+tagName+'\\\\s*>', 'i')).exec(rest);\n      if (! end)\n        throwParseError(\"unclosed <\"+tagName+\">\");\n      var tagContents = rest.slice(0, end.index);\n      var contentsStartIndex = index;\n\n      // act on the tag\n      html_scanner._handleTag(results, tagName, tagAttribs, tagContents,\n                              throwParseError, contentsStartIndex,\n                              tagStartIndex);\n\n      // advance afterwards, so that line numbers in errors are correct\n      advance(end.index + end[0].length);\n    }\n\n    return results;\n  },\n\n  _initResults: function() {\n    var results = {};\n    results.head = '';\n    results.body = '';\n    results.js = '';\n    return results;\n  },\n\n  _handleTag: function (results, tag, attribs, contents, throwParseError,\n                        contentsStartIndex, tagStartIndex) {\n\n    // trim the tag contents.\n    // this is a courtesy and is also relied on by some unit tests.\n    var m = contents.match(/^([ \\t\\r\\n]*)([\\s\\S]*?)[ \\t\\r\\n]*$/);\n    contentsStartIndex += m[1].length;\n    contents = m[2];\n\n    // do we have 1 or more attribs?\n    var hasAttribs = false;\n    for(var k in attribs) {\n      if (attribs.hasOwnProperty(k)) {\n        hasAttribs = true;\n        break;\n      }\n    }\n\n    if (tag === \"head\") {\n      if (hasAttribs)\n        throwParseError(\"Attributes on <head> not supported\");\n      results.head += contents;\n      return;\n    }\n\n\n    // <body> or <template>\n\n    try {\n      if (tag === \"template\") {\n        var name = attribs.name;\n        if (! name)\n          throwParseError(\"Template has no 'name' attribute\");\n\n        if (SpacebarsCompiler.isReservedName(name))\n          throwParseError(\"Template can't be named \\\"\" + name + \"\\\"\");\n\n        var renderFuncCode = SpacebarsCompiler.compile(\n          contents, {\n            isTemplate: true,\n            sourceName: 'Template \"' + name + '\"'\n          });\n\n        var nameLiteral = JSON.stringify(name);\n        var templateDotNameLiteral = JSON.stringify(\"Template.\" + name);\n\n        results.js += \"\\nTemplate.__checkName(\" + nameLiteral + \");\\n\" +\n          \"Template[\" + nameLiteral + \"] = new Template(\" +\n          templateDotNameLiteral + \", \" + renderFuncCode + \");\\n\";\n      } else {\n        // <body>\n        if (hasAttribs) {\n          // XXX we would want to throw an error here if we have duplicate\n          // attributes, but this is complex to do with the current build system\n          // so we won't.\n          results.js += \"\\nMeteor.startup(function() { $('body').attr(\" + JSON.stringify(attribs) + \"); });\\n\";\n        }\n\n        var renderFuncCode = SpacebarsCompiler.compile(\n          contents, {\n            isBody: true,\n            sourceName: \"<body>\"\n          });\n\n        // We may be one of many `<body>` tags.\n        results.js += \"\\nTemplate.body.addContent(\" + renderFuncCode + \");\\nMeteor.startup(Template.body.renderToDocument);\\n\";\n      }\n    } catch (e) {\n      if (e.scanner) {\n        // The error came from Spacebars\n        throwParseError(e.message, contentsStartIndex + e.offset);\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n","var path = Npm.require('path');\n\nvar doHTMLScanning = function (compileStep, htmlScanner) {\n  // XXX the way we deal with encodings here is sloppy .. should get\n  // religion on that\n  var contents = compileStep.read().toString('utf8');\n  try {\n    var results = htmlScanner.scan(contents, compileStep.inputPath);\n  } catch (e) {\n    if (e instanceof htmlScanner.ParseError) {\n      compileStep.error({\n        message: e.message,\n        sourcePath: compileStep.inputPath,\n        line: e.line\n      });\n      return;\n    } else\n      throw e;\n  }\n\n  if (results.head)\n    compileStep.appendDocument({ section: \"head\", data: results.head });\n\n  if (results.body)\n    compileStep.appendDocument({ section: \"body\", data: results.body });\n\n  if (results.js) {\n    var path_part = path.dirname(compileStep.inputPath);\n    if (path_part === '.')\n      path_part = '';\n    if (path_part.length && path_part !== path.sep)\n      path_part = path_part + path.sep;\n    var ext = path.extname(compileStep.inputPath);\n    var basename = path.basename(compileStep.inputPath, ext);\n\n    // XXX generate a source map\n\n    compileStep.addJavaScript({\n      path: path.join(path_part, \"template.\" + basename + \".js\"),\n      sourcePath: compileStep.inputPath,\n      data: results.js\n    });\n  }\n};\n\nPlugin.registerSourceHandler(\n  \"html\", {isTemplate: true, archMatching: 'web'},\n  function (compileStep) {\n    doHTMLScanning(compileStep, html_scanner);\n  }\n);\n"]}