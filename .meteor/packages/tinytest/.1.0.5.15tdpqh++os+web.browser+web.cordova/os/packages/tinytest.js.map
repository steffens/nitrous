{"version":3,"sources":["tinytest/tinytest.js","tinytest/model.js","tinytest/tinytest_server.js"],"names":[],"mappings":";;;;;;;;AAAA,W;AACA,oB;AACA,wC;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,8E;AACA,kB;AACA,6B;AACA,yB;AACA,iC;AACA,8B;AACA,uC;AACA,iC;AACA,wB;AACA,yB;AACA,E;;AAEA,qC;AACA,sB;AACA,oB;AACA,0B;AACA,Y;AACA,uB;AACA,iC;AACA,oC;AACA,iD;AACA,qC;AACA,K;AACA,qB;AACA,I;;AAEA,4B;AACA,oB;AACA,kC;AACA,I;;AAEA,wB;AACA,oB;;AAEA,kC;AACA,6D;AACA,+B;AACA,2C;AACA,K;;AAEA,+C;;AAEA,oC;AACA,4B;AACA,kD;AACA,8B;AACA,iB;AACA,oC;AACA,8E;AACA,O;AACA,iC;AACA,K;AACA,4B;AACA,4B;;AAEA,2E;AACA,a;AACA,kC;AACA,2D;AACA,oE;AACA,0B;AACA,mC;AACA,4B;AACA,uD;AACA,mD;AACA,6B;AACA,oE;AACA,mE;AACA,sD;AACA,6C;AACA,2C;AACA,gB;AACA,S;AACA,O;AACA,K;;AAEA,kB;AACA,kE;AACA,qB;AACA,4E;AACA,qD;AACA,qD;AACA,O;AACA,mC;AACA,8B;AACA,I;;AAEA,qE;AACA,kE;AACA,I;AACA,oE;AACA,kE;AACA,mE;AACA,yC;AACA,mC;AACA,gC;AACA,I;;AAEA,kE;AACA,e;AACA,sB;AACA,mB;AACA,I;;AAEA,mE;;AAEA,gD;AACA,oD;;AAEA,kD;AACA,yC;AACA,mD;AACA,a;AACA,K;;AAEA,oE;AACA,2E;AACA,O;;AAEA,gB;AACA,6C;AACA,wE;AACA,oC;AACA,0B;AACA,2B;AACA,qF;AACA,oF;AACA,oF;AACA,qF;AACA,gD;AACA,0C;AACA,sF;AACA,sF;AACA,4C;AACA,yF;AACA,sE;AACA,iD;AACA,2C;AACA,O;AACA,Y;AACA,+C;AACA,K;;AAEA,4B;AACA,wD;AACA,kG;AACA,U;AACA,gB;AACA,I;;AAEA,kD;AACA,gD;AACA,I;;AAEA,8C;AACA,6B;AACA,gB;AACA,Q;AACA,4F;AACA,I;;AAEA,iD;AACA,6B;AACA,2F;AACA,Q;AACA,gB;AACA,I;;AAEA,+C;AACA,4B;AACA,gB;AACA,Q;AACA,mD;AACA,yE;AACA,I;;AAEA,kD;AACA,4B;AACA,mD;AACA,wE;AACA,Q;AACA,gB;AACA,I;;AAEA,qB;AACA,sC;AACA,yE;AACA,8D;AACA,oE;AACA,I;AACA,kE;AACA,2D;AACA,gE;AACA,gE;AACA,8D;AACA,oE;AACA,mB;AACA,I;AACA,gE;AACA,gD;AACA,I;AACA,kC;AACA,0B;;AAEA,+B;AACA,qC;AACA,oB;AACA,Q;AACA,kC;AACA,qC;AACA,4C;AACA,uD;AACA,Q;AACA,wC;AACA,qC;AACA,6C;AACA,Q;AACA,4C;AACA,2B;AACA,Q;AACA,oF;;AAEA,S;AACA,U;AACA,yB;AACA,yB;AACA,K;;AAEA,oC;AACA,gB;AACA,Q;AACA,iB;AACA,uB;AACA,yB;AACA,mD;AACA,8C;AACA,S;AACA,I;;AAEA,6B;AACA,U;AACA,gB;AACA,Q;AACA,0D;AACA,I;;AAEA,8B;AACA,U;AACA,yD;AACA,Q;AACA,gB;AACA,I;;AAEA,6B;AACA,mB;AACA,gB;AACA,Q;AACA,0D;AACA,I;;AAEA,gC;AACA,mB;AACA,yD;AACA,Q;AACA,gB;AACA,I;;AAEA,kC;AACA,wB;AACA,gB;AACA,Q;AACA,+D;AACA,I;;AAEA,qC;AACA,wB;AACA,8D;AACA,Q;AACA,gB;AACA,I;;AAEA,4B;AACA,iB;AACA,gB;AACA,Q;AACA,yD;AACA,I;;AAEA,+B;AACA,iB;AACA,wD;AACA,Q;AACA,gB;AACA,I;;AAEA,0C;AACA,qB;AACA,2B;AACA,+D;AACA,mC;AACA,oB;AACA,mC;AACA,8B;AACA,oB;AACA,O;AACA,Q;AACA,6D;AACA,uB;AACA,gB;AACA,U;AACA,mD;AACA,oE;AACA,K;AACA,I;;AAEA,wC;AACA,sC;AACA,I;;AAEA,kD;AACA,gD;AACA,uC;AACA,gB;AACA,Q;AACA,2D;AACA,oD;AACA,I;;AAEA,4D;AACA,2D;AACA,Y;AACA,sD;AACA,8B;AACA,sC;AACA,kC;AACA,oC;AACA,kC;AACA,Y;AACA,gB;AACA,K;AACA,G;;;AAGA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,kC;AACA,kB;AACA,mB;AACA,mB;;AAEA,wD;AACA,+C;AACA,K;AACA,mC;AACA,gC;AACA,6B;AACA,E;;AAEA,8B;AACA,iE;AACA,qE;AACA,wD;AACA,oE;AACA,oB;;AAEA,0B;AACA,oC;AACA,sB;AACA,8D;AACA,oD;AACA,qB;AACA,O;AACA,uB;AACA,kB;AACA,M;;AAEA,uC;AACA,8E;AACA,6E;AACA,2D;AACA,oB;AACA,+C;AACA,wB;AACA,M;;AAEA,2D;AACA,oD;AACA,2D;AACA,yD;AACA,yD;;AAEA,8B;AACA,W;AACA,wC;AACA,6B;AACA,yB;AACA,W;AACA,mB;AACA,2B;AACA,yB;AACA,O;AACA,O;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,2B;AACA,kB;AACA,kB;AACA,0B;AACA,qE;AACA,E;;AAEA,qD;AACA,yE;AACA,C;;AAEA,iC;AACA,4B;AACA,oB;AACA,gC;AACA,sB;AACA,2E;AACA,2B;AACA,mD;AACA,6E;AACA,a;AACA,K;AACA,iC;AACA,kC;AACA,I;;AAEA,8C;AACA,oB;AACA,mD;AACA,G;AACA,G;;AAEA,Y;AACA,8B;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,oD;AACA,kB;AACA,yB;AACA,2B;AACA,gC;AACA,sC;AACA,sD;AACA,0C;AACA,yB;AACA,K;AACA,E;;AAEA,6B;;AAEA,qC;AACA,oB;AACA,uD;AACA,gE;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,yD;AACA,oB;;AAEA,gC;;AAEA,+B;AACA,mB;AACA,sE;AACA,sB;AACA,wB;AACA,e;AACA,gC;AACA,oB;AACA,sB;AACA,wB;AACA,e;AACA,8C;AACA,8D;AACA,mB;AACA,6B;AACA,uB;AACA,wB;AACA,e;;AAEA,4D;AACA,mC;AACA,0B;AACA,0B;AACA,kB;AACA,qD;AACA,mD;AACA,S;AACA,S;;AAEA,mB;AACA,uB;AACA,I;;AAEA,sE;AACA,sE;AACA,kE;AACA,wC;AACA,I;AACA,wD;AACA,oB;;AAEA,8C;AACA,iC;AACA,a;AACA,K;;AAEA,0B;AACA,sE;AACA,+B;AACA,oD;AACA,oE;AACA,kC;AACA,0B;AACA,uB;AACA,oC;AACA,mE;AACA,qB;AACA,iC;AACA,gC;AACA,gC;AACA,wB;AACA,yC;AACA,e;AACA,e;AACA,+B;AACA,Y;AACA,qC;AACA,U;AACA,yC;AACA,mE;AACA,kE;AACA,8B;AACA,oC;AACA,+B;AACA,2B;AACA,qD;AACA,sB;AACA,mC;AACA,S;AACA,Y;AACA,e;AACA,uC;AACA,mC;AACA,yB;AACA,K;AACA,I;;AAEA,8B;AACA,oB;AACA,oD;AACA,yC;AACA,0B;AACA,4C;AACA,M;;AAEA,+B;AACA,yB;AACA,8B;AACA,8B;AACA,iC;AACA,c;AACA,4B;AACA,mC;AACA,O;AACA,M;;AAEA,c;AACA,I;;AAEA,+D;AACA,iE;AACA,yC;AACA,wC;AACA,oB;AACA,+C;AACA,c;AACA,4D;AACA,kD;AACA,I;;AAEA,mC;AACA,oB;AACA,c;AACA,8E;AACA,Q;AACA,sB;AACA,mB;AACA,gC;AACA,2B;AACA,oB;AACA,O;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,c;;AAEA,2C;AACA,gD;AACA,E;;AAEA,sC;AACA,uD;AACA,e;AACA,iB;AACA,K;AACA,E;;AAEA,+D;AACA,+D;AACA,2D;AACA,4C;AACA,E;AACA,kE;AACA,4D;AACA,0B;AACA,E;;AAEA,gE;AACA,mE;AACA,qC;AACA,E;AACA,+D;AACA,gD;AACA,oC;AACA,E;;AAEA,iE;AACA,wD;AACA,+D;AACA,gD;AACA,mD;;;;;;;;;;;;;;;;;;;ACvpBA,wE;AACA,oE;;;;;;;;;;;;;;;;;;;ACDA,kC;AACA,uB;AACA,uB;;AAEA,wE;AACA,uB;AACA,kB;AACA,mC;AACA,kC;AACA,M;AACA,oC;AACA,2B;AACA,iE;AACA,K;AACA,oC;AACA,0D;AACA,qC;AACA,U;AACA,+D;AACA,G;AACA,e;AACA,G;;AAEA,gB;AACA,gD;AACA,yB;AACA,gD;AACA,mB;;AAEA,8B;;AAEA,4C;AACA,sB;AACA,2B;AACA,sD;AACA,2E;AACA,S;AACA,uC;AACA,yC;AACA,M;;AAEA,sC;AACA,4B;AACA,iE;AACA,oF;AACA,wB;AACA,O;AACA,iC;AACA,kC;AACA,M;;AAEA,iC;AACA,gE;AACA,sE;AACA,kC;AACA,2B;AACA,6B;AACA,M;;AAEA,yD;AACA,I;AACA,6C;AACA,yB;AACA,oD;AACA,qE;AACA,sB;AACA,oB;AACA,O;AACA,gC;AACA,gC;AACA,G;AACA,G","file":"/packages/tinytest.js","sourcesContent":["var Future;\nif (Meteor.isServer)\n  Future = Npm.require('fibers/future');\n\n/******************************************************************************/\n/* TestCaseResults                                                            */\n/******************************************************************************/\n\nTestCaseResults = function (test_case, onEvent, onException, stop_at_offset) {\n  var self = this;\n  self.test_case = test_case;\n  self.onEvent = onEvent;\n  self.expecting_failure = false;\n  self.current_fail_count = 0;\n  self.stop_at_offset = stop_at_offset;\n  self.onException = onException;\n  self.id = Random.id();\n  self.extraDetails = {};\n};\n\n_.extend(TestCaseResults.prototype, {\n  ok: function (doc) {\n    var self = this;\n    var ok = {type: \"ok\"};\n    if (doc)\n      ok.details = doc;\n    if (self.expecting_failure) {\n      ok.details = ok.details || {};\n      ok.details[\"was_expecting_failure\"] = true;\n      self.expecting_failure = false;\n    }\n    self.onEvent(ok);\n  },\n\n  expect_fail: function () {\n    var self = this;\n    self.expecting_failure = true;\n  },\n\n  fail: function (doc) {\n    var self = this;\n\n    if (typeof doc === \"string\") {\n      // Some very old code still tries to call fail() with a\n      // string. Don't do this!\n      doc = { type: \"fail\", message: doc };\n    }\n\n    doc = _.extend({}, doc, self.extraDetails);\n\n    if (self.stop_at_offset === 0) {\n      if (Meteor.isClient) {\n        // Only supported on the browser for now..\n        var now = (+new Date);\n        debugger;\n        if ((+new Date) - now < 100)\n          alert(\"To use this feature, first enable your browser's debugger.\");\n      }\n      self.stop_at_offset = null;\n    }\n    if (self.stop_at_offset)\n      self.stop_at_offset--;\n\n    // Get filename and line number of failure if we're using v8 (Chrome or\n    // Node).\n    if (Error.captureStackTrace) {\n      var savedPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = function(_, stack){ return stack; };\n      var err = new Error;\n      Error.captureStackTrace(err);\n      var stack = err.stack;\n      Error.prepareStackTrace = savedPrepareStackTrace;\n      for (var i = stack.length - 1; i >= 0; --i) {\n        var frame = stack[i];\n        // Heuristic: use the OUTERMOST line which is in a :tests.js\n        // file (this is less likely to be a test helper function).\n        if (frame.getFileName().match(/:tests\\.js/)) {\n          doc.filename = frame.getFileName();\n          doc.line = frame.getLineNumber();\n          break;\n        }\n      }\n    }\n\n    self.onEvent({\n        type: (self.expecting_failure ? \"expected_fail\" : \"fail\"),\n        details: doc,\n        cookie: {name: self.test_case.name, offset: self.current_fail_count,\n                 groupPath: self.test_case.groupPath,\n                 shortName: self.test_case.shortName}\n    });\n    self.expecting_failure = false;\n    self.current_fail_count++;\n  },\n\n  // Call this to fail the test with an exception. Use this to record\n  // exceptions that occur inside asynchronous callbacks in tests.\n  //\n  // It should only be used with asynchronous tests, and if you call\n  // this function, you should make sure that (1) the test doesn't\n  // call its callback (onComplete function); (2) the test function\n  // doesn't directly raise an exception.\n  exception: function (exception) {\n    this.onException(exception);\n  },\n\n  // returns a unique ID for this test run, for convenience use by\n  // your tests\n  runId: function () {\n    return this.id;\n  },\n\n  // === Following patterned after http://vowsjs.org/#reference ===\n\n  // XXX eliminate 'message' and 'not' arguments\n  equal: function (actual, expected, message, not) {\n\n    if ((! not) && (typeof actual === 'string') &&\n        (typeof expected === 'string')) {\n      this._stringEqual(actual, expected, message);\n      return;\n    }\n\n    /* If expected is a DOM node, do a literal '===' comparison with\n     * actual. Otherwise do a deep comparison, as implemented by _.isEqual.\n     */\n\n    var matched;\n    // XXX remove cruft specific to liverange\n    if (typeof expected === \"object\" && expected && expected.nodeType) {\n      matched = expected === actual;\n      expected = \"[Node]\";\n      actual = \"[Unknown]\";\n    } else if (typeof Uint8Array !== 'undefined' && expected instanceof Uint8Array) {\n      // I have no idea why but _.isEqual on Chrome horks completely on Uint8Arrays.\n      // and the symptom is the chrome renderer taking up an entire CPU and freezing\n      // your web page, but not pausing anywhere in _.isEqual.  I don't understand it\n      // but we fall back to a manual comparison\n      if (!(actual instanceof Uint8Array))\n        this.fail({type: \"assert_equal\", message: \"found object is not a typed array\",\n                   expected: \"A typed array\", actual: actual.constructor.toString()});\n      if (expected.length !== actual.length)\n        this.fail({type: \"assert_equal\", message: \"lengths of typed arrays do not match\",\n                   expected: expected.length, actual: actual.length});\n      for (var i = 0; i < expected.length; i++) {\n        this.equal(actual[i], expected[i]);\n      }\n    } else {\n      matched = EJSON.equals(expected, actual);\n    }\n\n    if (matched === !!not) {\n      this.fail({type: \"assert_equal\", message: message,\n                 expected: JSON.stringify(expected), actual: JSON.stringify(actual), not: !!not});\n    } else\n      this.ok();\n  },\n\n  notEqual: function (actual, expected, message) {\n    this.equal(actual, expected, message, true);\n  },\n\n  instanceOf: function (obj, klass, message) {\n    if (obj instanceof klass)\n      this.ok();\n    else\n      this.fail({type: \"instanceOf\", message: message, not: false}); // XXX what other data?\n  },\n\n  notInstanceOf: function (obj, klass, message) {\n    if (obj instanceof klass)\n      this.fail({type: \"instanceOf\", message: message, not: true}); // XXX what other data?\n    else\n      this.ok();\n  },\n\n  matches: function (actual, regexp, message) {\n    if (regexp.test(actual))\n      this.ok();\n    else\n      this.fail({type: \"matches\", message: message,\n                 actual: actual, regexp: regexp.toString(), not: false});\n  },\n\n  notMatches: function (actual, regexp, message) {\n    if (regexp.test(actual))\n      this.fail({type: \"matches\", message: message,\n                 actual: actual, regexp: regexp.toString(), not: true});\n    else\n      this.ok();\n  },\n\n  // expected can be:\n  //  undefined: accept any exception.\n  //  string: pass if the string is a substring of the exception message.\n  //  regexp: pass if the exception message passes the regexp.\n  //  function: call the function as a predicate with the exception.\n  //\n  // Note: Node's assert.throws also accepts a constructor to test\n  // whether the error is of the expected class.  But since\n  // JavaScript can't distinguish between constructors and plain\n  // functions and Node's assert.throws also accepts a predicate\n  // function, if the error fails the instanceof test with the\n  // constructor then the constructor is then treated as a predicate\n  // and called (!)\n  //\n  // The upshot is, if you want to test whether an error is of a\n  // particular class, use a predicate function.\n  //\n  throws: function (f, expected) {\n    var actual, predicate;\n\n    if (expected === undefined)\n      predicate = function (actual) {\n        return true;\n      };\n    else if (_.isString(expected))\n      predicate = function (actual) {\n        return _.isString(actual.message) &&\n               actual.message.indexOf(expected) !== -1;\n      };\n    else if (expected instanceof RegExp)\n      predicate = function (actual) {\n        return expected.test(actual.message);\n      };\n    else if (typeof expected === 'function')\n      predicate = expected;\n    else\n      throw new Error('expected should be a string, regexp, or predicate function');\n\n    try {\n      f();\n    } catch (exception) {\n      actual = exception;\n    }\n\n    if (actual && predicate(actual))\n      this.ok();\n    else\n      this.fail({\n        type: \"throws\",\n        message: actual ?\n          \"wrong error thrown: \" + actual.message :\n          \"did not throw an error as expected\"\n      });\n  },\n\n  isTrue: function (v, msg) {\n    if (v)\n      this.ok();\n    else\n      this.fail({type: \"true\", message: msg, not: false});\n  },\n\n  isFalse: function (v, msg) {\n    if (v)\n      this.fail({type: \"true\", message: msg, not: true});\n    else\n      this.ok();\n  },\n\n  isNull: function (v, msg) {\n    if (v === null)\n      this.ok();\n    else\n      this.fail({type: \"null\", message: msg, not: false});\n  },\n\n  isNotNull: function (v, msg) {\n    if (v === null)\n      this.fail({type: \"null\", message: msg, not: true});\n    else\n      this.ok();\n  },\n\n  isUndefined: function (v, msg) {\n    if (v === undefined)\n      this.ok();\n    else\n      this.fail({type: \"undefined\", message: msg, not: false});\n  },\n\n  isNotUndefined: function (v, msg) {\n    if (v === undefined)\n      this.fail({type: \"undefined\", message: msg, not: true});\n    else\n      this.ok();\n  },\n\n  isNaN: function (v, msg) {\n    if (isNaN(v))\n      this.ok();\n    else\n      this.fail({type: \"NaN\", message: msg, not: false});\n  },\n\n  isNotNaN: function (v, msg) {\n    if (isNaN(v))\n      this.fail({type: \"NaN\", message: msg, not: true});\n    else\n      this.ok();\n  },\n\n  include: function (s, v, message, not) {\n    var pass = false;\n    if (s instanceof Array)\n      pass = _.any(s, function(it) {return _.isEqual(v, it);});\n    else if (typeof s === \"object\")\n      pass = v in s;\n    else if (typeof s === \"string\")\n      if (s.indexOf(v) > -1) {\n        pass = true;\n      }\n    else\n      /* fail -- not something that contains other things */;\n    if (pass === ! not)\n      this.ok();\n    else {\n      this.fail({type: \"include\", message: message,\n                 sequence: s, should_contain_value: v, not: !!not});\n    }\n  },\n\n  notInclude: function (s, v, message) {\n    this.include(s, v, message, true);\n  },\n\n  // XXX should change to lengthOf to match vowsjs\n  length: function (obj, expected_length, msg) {\n    if (obj.length === expected_length)\n      this.ok();\n    else\n      this.fail({type: \"length\", expected: expected_length,\n                 actual: obj.length, message: msg});\n  },\n\n  // EXPERIMENTAL way to compare two strings that results in\n  // a nicer display in the test runner, e.g. for multiline\n  // strings\n  _stringEqual: function (actual, expected, message) {\n    if (actual !== expected) {\n      this.fail({type: \"string_equal\",\n                 message: message,\n                 expected: expected,\n                 actual: actual});\n    } else {\n      this.ok();\n    }\n  }\n\n\n});\n\n/******************************************************************************/\n/* TestCase                                                                   */\n/******************************************************************************/\n\nTestCase = function (name, func) {\n  var self = this;\n  self.name = name;\n  self.func = func;\n\n  var nameParts = _.map(name.split(\" - \"), function(s) {\n    return s.replace(/^\\s*|\\s*$/g, \"\"); // trim\n  });\n  self.shortName = nameParts.pop();\n  nameParts.unshift(\"tinytest\");\n  self.groupPath = nameParts;\n};\n\n_.extend(TestCase.prototype, {\n  // Run the test asynchronously, delivering results via onEvent;\n  // then call onComplete() on success, or else onException(e) if the\n  // test raised (or voluntarily reported) an exception.\n  run: function (onEvent, onComplete, onException, stop_at_offset) {\n    var self = this;\n\n    var completed = false;\n    var markComplete = function () {\n      if (completed) {\n        Meteor._debug(\"*** Test error -- test '\" + self.name +\n                      \"' returned multiple times.\");\n        return false;\n      }\n      completed = true;\n      return true;\n    };\n\n    var wrappedOnEvent = function (e) {\n      // If this trace prints, it means you ran some test.* function after the\n      // test finished! Another symptom will be that the test will display as\n      // \"waiting\" even when it counts as passed or failed.\n      if (completed)\n        console.trace(\"event after complete!\");\n      return onEvent(e);\n    };\n\n    var results = new TestCaseResults(self, wrappedOnEvent,\n                                      function (e) {\n                                        if (markComplete())\n                                          onException(e);\n                                      }, stop_at_offset);\n\n    Meteor.defer(function () {\n      try {\n        self.func(results, function () {\n          if (markComplete())\n            onComplete();\n        });\n      } catch (e) {\n        if (markComplete())\n          onException(e);\n      }\n    });\n  }\n});\n\n/******************************************************************************/\n/* TestManager                                                                */\n/******************************************************************************/\n\nTestManager = function () {\n  var self = this;\n  self.tests = {};\n  self.ordered_tests = [];\n  self.testQueue = Meteor.isServer && new Meteor._SynchronousQueue();\n};\n\nif (Meteor.isServer && process.env.TINYTEST_FILTER) {\n  __meteor_runtime_config__.tinytestFilter = process.env.TINYTEST_FILTER;\n}\n\n_.extend(TestManager.prototype, {\n  addCase: function (test) {\n    var self = this;\n    if (test.name in self.tests)\n      throw new Error(\n        \"Every test needs a unique name, but there are two tests named '\" +\n          test.name + \"'\");\n    if (__meteor_runtime_config__.tinytestFilter &&\n        test.name.indexOf(__meteor_runtime_config__.tinytestFilter) === -1) {\n      return;\n    }\n    self.tests[test.name] = test;\n    self.ordered_tests.push(test);\n  },\n\n  createRun: function (onReport, pathPrefix) {\n    var self = this;\n    return new TestRun(self, onReport, pathPrefix);\n  }\n});\n\n// singleton\nTestManager = new TestManager;\n\n/******************************************************************************/\n/* TestRun                                                                    */\n/******************************************************************************/\n\nTestRun = function (manager, onReport, pathPrefix) {\n  var self = this;\n  self.manager = manager;\n  self.onReport = onReport;\n  self.next_sequence_number = 0;\n  self._pathPrefix = pathPrefix || [];\n  _.each(self.manager.ordered_tests, function (test) {\n    if (self._prefixMatch(test.groupPath))\n      self._report(test);\n  });\n};\n\n_.extend(TestRun.prototype, {\n\n  _prefixMatch: function (testPath) {\n    var self = this;\n    for (var i = 0; i < self._pathPrefix.length; i++) {\n      if (!testPath[i] || self._pathPrefix[i] !== testPath[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _runTest: function (test, onComplete, stop_at_offset) {\n    var self = this;\n\n    var startTime = (+new Date);\n\n    test.run(function (event) {\n      /* onEvent */\n      // Ignore result callbacks if the test has already been reported\n      // as timed out.\n      if (test.timedOut)\n        return;\n      self._report(test, event);\n    }, function () {\n      /* onComplete */\n      if (test.timedOut)\n        return;\n      var totalTime = (+new Date) - startTime;\n      self._report(test, {type: \"finish\", timeMs: totalTime});\n      onComplete();\n    }, function (exception) {\n      /* onException */\n      if (test.timedOut)\n        return;\n\n      // XXX you want the \"name\" and \"message\" fields on the\n      // exception, to start with..\n      self._report(test, {\n        type: \"exception\",\n        details: {\n          message: exception.message, // XXX empty???\n          stack: exception.stack // XXX portability\n        }\n      });\n\n      onComplete();\n    }, stop_at_offset);\n  },\n\n  // Run a single test.  On the server, ensure that only one test runs\n  // at a time, even with multiple clients submitting tests.  However,\n  // time out the test after three minutes to avoid locking up the\n  // server if a test fails to complete.\n  //\n  _runOne: function (test, onComplete, stop_at_offset) {\n    var self = this;\n\n    if (! self._prefixMatch(test.groupPath)) {\n      onComplete && onComplete();\n      return;\n    }\n\n    if (Meteor.isServer) {\n      // On the server, ensure that only one test runs at a time, even\n      // with multiple clients.\n      self.manager.testQueue.queueTask(function () {\n        // The future resolves when the test completes or times out.\n        var future = new Future();\n        Meteor.setTimeout(\n          function () {\n            if (future.isResolved())\n              // If the future has resolved the test has completed.\n              return;\n            test.timedOut = true;\n            self._report(test, {\n              type: \"exception\",\n              details: {\n                message: \"test timed out\"\n              }\n            });\n            future['return']();\n          },\n          3 * 60 * 1000  // 3 minutes\n        );\n        self._runTest(test, function () {\n          // The test can complete after it has timed out (it might\n          // just be slow), so only resolve the future if the test\n          // hasn't timed out.\n          if (! future.isResolved())\n            future['return']();\n        }, stop_at_offset);\n        // Wait for the test to complete or time out.\n        future.wait();\n        onComplete && onComplete();\n      });\n    } else {\n      // client\n      self._runTest(test, function () {\n        onComplete && onComplete();\n      }, stop_at_offset);\n    }\n  },\n\n  run: function (onComplete) {\n    var self = this;\n    var tests = _.clone(self.manager.ordered_tests);\n    var reportCurrent = function (name) {\n      if (Meteor.isClient)\n        Tinytest._onCurrentClientTest(name);\n    };\n\n    var runNext = function () {\n      if (tests.length) {\n        var t = tests.shift();\n        reportCurrent(t.name);\n        self._runOne(t, runNext);\n      } else {\n        reportCurrent(null);\n        onComplete && onComplete();\n      }\n    };\n\n    runNext();\n  },\n\n  // An alternative to run(). Given the 'cookie' attribute of a\n  // failure record, try to rerun that particular test up to that\n  // failure, and then open the debugger.\n  debug: function (cookie, onComplete) {\n    var self = this;\n    var test = self.manager.tests[cookie.name];\n    if (!test)\n      throw new Error(\"No such test '\" + cookie.name + \"'\");\n    self._runOne(test, onComplete, cookie.offset);\n  },\n\n  _report: function (test, event) {\n    var self = this;\n    if (event)\n      var events = [_.extend({sequence: self.next_sequence_number++}, event)];\n    else\n      var events = [];\n    self.onReport({\n      groupPath: test.groupPath,\n      test: test.shortName,\n      events: events\n    });\n  }\n});\n\n/******************************************************************************/\n/* Public API                                                                 */\n/******************************************************************************/\n\nTinytest = {};\n\nTinytest.addAsync = function (name, func) {\n  TestManager.addCase(new TestCase(name, func));\n};\n\nTinytest.add = function (name, func) {\n  Tinytest.addAsync(name, function (test, onComplete) {\n    func(test);\n    onComplete();\n  });\n};\n\n// Run every test, asynchronously. Runs the test in the current\n// process only (if called on the server, runs the tests on the\n// server, and likewise for the client.) Report results via\n// onReport. Call onComplete when it's done.\n//\nTinytest._runTests = function (onReport, onComplete, pathPrefix) {\n  var testRun = TestManager.createRun(onReport, pathPrefix);\n  testRun.run(onComplete);\n};\n\n// Run just one test case, and stop the debugger at a particular\n// error, all as indicated by 'cookie', which will have come from a\n// failure event output by _runTests.\n//\nTinytest._debugTest = function (cookie, onReport, onComplete) {\n  var testRun = TestManager.createRun(onReport);\n  testRun.debug(cookie, onComplete);\n};\n\n// Replace this callback to get called when we run a client test,\n// and then called with `null` when the client tests are\n// done.  This is used to provide a live display of the current\n// running client test on the test results page.\nTinytest._onCurrentClientTest = function (name) {};\n","Meteor._ServerTestResultsSubscription = 'tinytest_results_subscription';\nMeteor._ServerTestResultsCollection = 'tinytest_results_collection';\n","var Fiber = Npm.require('fibers');\nvar handlesForRun = {};\nvar reportsForRun = {};\n\nMeteor.publish(Meteor._ServerTestResultsSubscription, function (runId) {\n  check(runId, String);\n  var self = this;\n  if (!_.has(handlesForRun, runId))\n    handlesForRun[runId] = [self];\n  else\n    handlesForRun[runId].push(self);\n  self.onStop(function () {\n    handlesForRun[runId] = _.without(handlesForRun[runId], self);\n  });\n  if (_.has(reportsForRun, runId)) {\n    self.added(Meteor._ServerTestResultsCollection, runId,\n               reportsForRun[runId]);\n  } else {\n    self.added(Meteor._ServerTestResultsCollection, runId, {});\n  }\n  self.ready();\n});\n\nMeteor.methods({\n  'tinytest/run': function (runId, pathPrefix) {\n    check(runId, String);\n    check(pathPrefix, Match.Optional([String]));\n    this.unblock();\n\n    reportsForRun[runId] = {};\n\n    var addReport = function (key, report) {\n      var fields = {};\n      fields[key] = report;\n      _.each(handlesForRun[runId], function (handle) {\n        handle.changed(Meteor._ServerTestResultsCollection, runId, fields);\n      });\n      // Save for future subscriptions.\n      reportsForRun[runId][key] = report;\n    };\n\n    var onReport = function (report) {\n      if (! Fiber.current) {\n        Meteor._debug(\"Trying to report a test not in a fiber! \"+\n                      \"You probably forgot to wrap a callback in bindEnvironment.\");\n        console.trace();\n      }\n      var dummyKey = Random.id();\n      addReport(dummyKey, report);\n    };\n\n    var onComplete = function() {\n      // We send an object for current and future compatibility,\n      // though we could get away with just sending { complete: true }\n      var report = { done: true };\n      var key = 'complete';\n      addReport(key, report);\n    };\n\n    Tinytest._runTests(onReport, onComplete, pathPrefix);\n  },\n  'tinytest/clearResults': function (runId) {\n    check(runId, String);\n    _.each(handlesForRun[runId], function (handle) {\n      // XXX this doesn't actually notify the client that it has been\n      // unsubscribed.\n      handle.stop();\n    });\n    delete handlesForRun[runId];\n    delete reportsForRun[runId];\n  }\n});\n"]}