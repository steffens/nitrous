{"version":3,"sources":["test-in-console/driver.js"],"names":[],"mappings":";;;;;;;;AAAA,6E;AACA,a;AACA,wC;AACA,gB;;AAEA,e;AACA,c;AACA,gB;AACA,E;;AAEA,+B;AACA,oB;AACA,c;AACA,c;AACA,e;AACA,gB;AACA,e;AACA,E;;AAEA,0C;AACA,8B;AACA,6C;AACA,2B;AACA,K;AACA,C;;AAEA,kC;AACA,iC;AACA,0C;AACA,uD;AACA,E;;AAEA,0E;AACA,oC;AACA,uC;AACA,0C;AACA,G;AACA,E;;AAEA,uC;AACA,+C;AACA,sF;AACA,uE;AACA,uC;AACA,0C;AACA,E;;AAEA,gD;AACA,8C;AACA,0B;AACA,qB;AACA,yB;AACA,G;AACA,E;;AAEA,e;AACA,e;AACA,iB;AACA,mB;AACA,kB;;AAEA,iD;AACA,oF;AACA,c;AACA,qB;;AAEA,gD;AACA,yC;;AAEA,wB;AACA,wB;AACA,+B;AACA,mC;AACA,oC;AACA,iB;AACA,gB;AACA,2C;AACA,yC;AACA,qC;AACA,yB;AACA,qC;AACA,8B;AACA,M;AACA,iE;AACA,6C;AACA,gD;AACA,2C;AACA,K;AACA,a;AACA,4B;AACA,Q;AACA,8B;AACA,2C;AACA,G;AACA,E;AACA,uC;AACA,yB;AACA,gB;AACA,8B;AACA,gB;AACA,e;AACA,6C;AACA,M;AACA,e;AACA,E;AACA,4B;AACA,+B;AACA,iC;;AAEA,+B;AACA,wB;AACA,kC;AACA,oC;AACA,sD;AACA,oC;AACA,2B;AACA,qB;AACA,4B;AACA,qB;AACA,mC;AACA,6B;AACA,4B;AACA,U;AACA,4B;AACA,O;AACA,6D;AACA,6C;AACA,+C;AACA,2C;AACA,6B;AACA,kB;AACA,gB;AACA,6B;AACA,gD;AACA,gD;AACA,gB;AACA,yB;AACA,uD;AACA,mD;AACA,qC;AACA,c;AACA,8C;AACA,mB;AACA,gB;AACA,sB;AACA,2C;AACA,oB;AACA,kB;AACA,yB;AACA,0C;AACA,+B;AACA,iC;AACA,qB;AACA,kB;AACA,0B;AACA,+B;AACA,+C;AACA,uB;AACA,kB;AACA,sB;AACA,qB;AACA,+B;AACA,yD;AACA,sD;AACA,kB;AACA,kB;AACA,+D;AACA,W;AACA,gB;AACA,gB;AACA,0C;AACA,yC;AACA,gB;AACA,S;AACA,S;AACA,M;;AAEA,iD;AACA,iB;AACA,uB;AACA,kD;AACA,O;AACA,sG;AACA,+B;AACA,uB;AACA,iE;AACA,kC;AACA,qD;AACA,2C;AACA,mB;AACA,gB;AACA,mD;AACA,yC;AACA,S;AACA,S;;AAEA,8B;AACA,yF;AACA,iD;AACA,+G;AACA,4F;AACA,sB;AACA,uB;AACA,gD;AACA,+B;AACA,0B;AACA,wC;AACA,yC;AACA,4C;AACA,e;AACA,oB;AACA,6B;AACA,gD;AACA,6H;AACA,oB;AACA,W;AACA,W;AACA,gC;AACA,sB;AACA,iC;AACA,kB;AACA,0B;AACA,yB;AACA,kB;AACA,S;;AAEA,wH;AACA,oB;AACA,wF;AACA,S;AACA,6B;AACA,S;AACA,4B;AACA,gC;AACA,M;AACA,kB;AACA,G","file":"/packages/test-in-console.js","sourcesContent":["// Global flag for phantomjs (or other browser) to eval to see if we're done.\nDONE = false;\n// Failure count for phantomjs exit code\nFAILURES = null;\n\nTEST_STATUS = {\n  DONE: false,\n  FAILURES: null\n};\n\n// xUnit format uses XML output\nvar XML_CHAR_MAP = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  '\"': '&quot;',\n  \"'\": '&apos;'\n};\n\n// Escapes a string for insertion into XML\nvar escapeXml = function (s) {\n  return s.replace(/[<>&\"']/g, function (c) {\n    return XML_CHAR_MAP[c];\n  });\n}\n\n// Returns a human name for a test\nvar getName = function (result) {\n  return (result.server ? \"S: \" : \"C: \") +\n    result.groupPath.join(\" - \") + \" - \" + result.test;\n};\n\n// Calls console.log, but returns silently if console.log is not available\nvar log = function (/*arguments*/) {\n  if (typeof console !== 'undefined') {\n    console.log.apply(console, arguments);\n  }\n};\n\nvar MAGIC_PREFIX = '##_meteor_magic##';\n// Write output so that other tools can read it\n// Output is sent to console.log, prefixed with the magic prefix and then the facility\n// By grepping for the prefix, other tools can get the 'special' output\nvar logMagic = function (facility, s) {\n  log(MAGIC_PREFIX + facility + ': ' + s);\n};\n\n// Logs xUnit output, if xunit output is enabled\n// This uses logMagic with a facility of xunit\nvar xunit = function (s) {\n  if (xunitEnabled) {\n    logMagic('xunit', s);\n  }\n};\n\nvar passed = 0;\nvar failed = 0;\nvar expected = 0;\nvar resultSet = {};\nvar toReport = [];\n\nvar hrefPath = document.location.href.split(\"/\");\nvar platform = decodeURIComponent(hrefPath.length && hrefPath[hrefPath.length - 1]);\nif (!platform)\n  platform = \"local\";\n\n// We enable xUnit output when platform is xunit\nvar xunitEnabled = (platform == 'xunit');\n\nvar doReport = Meteor &&\n      Meteor.settings &&\n      Meteor.settings.public &&\n      Meteor.settings.public.runId;\nvar report = function (name, last) {\n  if (doReport) {\n    var data = {\n      run_id: Meteor.settings.public.runId,\n      testPath: resultSet[name].testPath,\n      status: resultSet[name].status,\n      platform: platform,\n      server: resultSet[name].server,\n      fullName: name.substr(3)\n    };\n    if ((data.status === \"FAIL\" || data.status === \"EXPECTED\") &&\n        !_.isEmpty(resultSet[name].events)) {\n      // only send events when bad things happen\n      data.events = resultSet[name].events;\n    }\n    if (last)\n      data.end = new Date();\n    else\n      data.start = new Date();\n    toReport.push(EJSON.toJSONValue(data));\n  }\n};\nvar sendReports = function (callback) {\n  var reports = toReport;\n  if (!callback)\n    callback = function () {};\n  toReport = [];\n  if (doReport)\n    Meteor.call(\"report\", reports, callback);\n  else\n    callback();\n};\nMeteor.startup(function () {\n  setTimeout(sendReports, 500);\n  setInterval(sendReports, 2000);\n\n  Tinytest._runTestsEverywhere(\n    function (results) {\n      var name = getName(results);\n      if (!_.has(resultSet, name)) {\n        var testPath = EJSON.clone(results.groupPath);\n        testPath.push(results.test);\n        resultSet[name] = {\n          name: name,\n          status: \"PENDING\",\n          events: [],\n          server: !!results.server,\n          testPath: testPath,\n          test: results.test\n        };\n        report(name, false);\n      }\n      // Loop through events, and record status for each test\n      // Also log result if test has finished\n      _.each(results.events, function (event) {\n        resultSet[name].events.push(event);\n        switch (event.type) {\n        case \"ok\":\n          break;\n        case \"expected_fail\":\n          if (resultSet[name].status !== \"FAIL\")\n            resultSet[name].status = \"EXPECTED\";\n          break;\n        case \"exception\":\n          log(name, \":\", \"!!!!!!!!! FAIL !!!!!!!!!!!\");\n          if (event.details && event.details.stack)\n            log(event.details.stack);\n          else\n            log(\"Test failed with exception\");\n          failed++;\n          break;\n        case \"finish\":\n          switch (resultSet[name].status) {\n          case \"OK\":\n            break;\n          case \"PENDING\":\n            resultSet[name].status = \"OK\";\n            report(name, true);\n            log(name, \":\", \"OK\");\n            passed++;\n            break;\n          case \"EXPECTED\":\n            report(name, true);\n            log(name, \":\", \"EXPECTED FAILURE\");\n            expected++;\n            break;\n          case \"FAIL\":\n            failed++;\n            report(name, true);\n            log(name, \":\", \"!!!!!!!!! FAIL !!!!!!!!!!!\");\n            log(JSON.stringify(resultSet[name].info));\n            break;\n          default:\n            log(name, \": unknown state for the test to be in\");\n          }\n          break;\n        default:\n          resultSet[name].status = \"FAIL\";\n          resultSet[name].info = results;\n          break;\n        }\n      });\n    },\n\n    // After test completion, log a quick summary\n    function () {\n      if (failed > 0) {\n        log(\"~~~~~~~ THERE ARE FAILURES ~~~~~~~\");\n      }\n      log(\"passed/expected/failed/total\", passed, \"/\", expected, \"/\", failed, \"/\", _.size(resultSet));\n      sendReports(function () {\n        if (doReport) {\n          log(\"Waiting 3s for any last reports to get sent out\");\n          setTimeout(function () {\n            TEST_STATUS.FAILURES = FAILURES = failed;\n            TEST_STATUS.DONE = DONE = true;\n          }, 3000);\n        } else {\n          TEST_STATUS.FAILURES = FAILURES = failed;\n          TEST_STATUS.DONE = DONE = true;\n        }\n      });\n\n      // Also log xUnit output\n      xunit('<testsuite errors=\"\" failures=\"\" name=\"meteor\" skips=\"\" tests=\"\" time=\"\">');\n      _.each(resultSet, function (result, name) {\n        var classname = result.testPath.join('.').replace(/ /g, '-') + (result.server ? \"-server\" : \"-client\");\n        var name = result.test.replace(/ /g, '-') + (result.server ? \"-server\" : \"-client\");\n        var time = \"\";\n        var error = \"\";\n        _.each(result.events, function (event) {\n          switch (event.type) {\n            case \"finish\":\n              var timeMs = event.timeMs;\n              if (timeMs !== undefined) {\n                time = (timeMs / 1000) + \"\";\n              }\n              break;\n            case \"exception\":\n              var details = event.details || {};\n              error = (details.message || '?') + \" filename=\" + (details.filename || '?') + \" line=\" + (details.line || '?');\n              break;\n          }\n        });\n        switch (result.status) {\n          case \"FAIL\":\n            error = error || '?';\n            break;\n          case \"EXPECTED\":\n            error = null;\n            break;\n        }\n\n        xunit('<testcase classname=\"' + escapeXml(classname) + '\" name=\"' + escapeXml(name) + '\" time=\"' + time + '\">');\n        if (error) {\n          xunit('  <failure message=\"test failure\">' + escapeXml(error) + '</failure>');\n        }\n        xunit('</testcase>');\n      });\n      xunit('</testsuite>');\n      logMagic('state', 'done');\n    },\n    [\"tinytest\"]);\n});\n"]}